34fb39a5eda774086aa6a272c85f9583
"use strict";
// Mock all dependencies before importing the component
jest.mock('@/contexts/SettingsContext', ()=>({
        useSettings: ()=>{
            console.log('Mock useSettings called');
            return {
                settings: {
                    id: '1',
                    userId: 'user1',
                    notifications: {
                        emailNotifications: true,
                        pushNotifications: false,
                        deploymentAlerts: true,
                        performanceAlerts: false,
                        securityAlerts: true
                    },
                    display: {
                        theme: 'light',
                        dashboardLayout: 'grid',
                        metricsTimeRange: '24h',
                        compactView: false
                    },
                    integrations: {
                        githubEnabled: true,
                        githubRepositories: [
                            'user/repo1',
                            'user/repo2'
                        ],
                        slackEnabled: false,
                        slackChannel: '#devops',
                        jiraEnabled: false,
                        jiraProject: 'OPS'
                    },
                    updatedAt: '2024-01-01T00:00:00Z'
                },
                loading: false,
                error: null,
                updateSettings: jest.fn().mockResolvedValue(undefined),
                resetSettings: jest.fn().mockResolvedValue(undefined),
                clearError: jest.fn()
            };
        }
    }));
jest.mock('@/components/auth/withAuth', ()=>({
        withAuth: (Component)=>Component
    }));
jest.mock('@/components/settings/GitHubRepoModal', ()=>({
        GitHubRepoModal: ()=>null
    }));
jest.mock('@/components/settings/ThemeSelector', ()=>({
        ThemeSelector: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "theme-selector",
                children: "Theme Selector"
            })
    }));
jest.mock('framer-motion', ()=>({
        motion: {
            div: ({ children, ...props })=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    ...props,
                    children: children
                }),
            button: ({ children, ...props })=>/*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                    ...props,
                    children: children
                }),
            section: ({ children, ...props })=>/*#__PURE__*/ (0, _jsxruntime.jsx)("section", {
                    ...props,
                    children: children
                })
        },
        AnimatePresence: ({ children })=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
                children: children
            })
    }));
jest.mock('@heroicons/react/24/outline', ()=>{
    const MockIcon = ({ className, ...props })=>/*#__PURE__*/ (0, _jsxruntime.jsx)("svg", {
            className: className,
            ...props,
            "data-testid": "mock-icon",
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)("circle", {
                cx: "12",
                cy: "12",
                r: "10"
            })
        });
    return {
        CogIcon: MockIcon,
        CheckIcon: MockIcon,
        ExclamationTriangleIcon: MockIcon,
        SwatchIcon: MockIcon,
        BellIcon: MockIcon,
        CodeBracketIcon: MockIcon,
        ArrowPathIcon: MockIcon,
        CheckCircleIcon: MockIcon,
        XMarkIcon: MockIcon
    };
});
jest.mock('@/utils/cn', ()=>({
        cn: (...classes)=>classes.filter(Boolean).join(' ')
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Test imports step by step
describe('Debug Tests', ()=>{
    test('basic test works', ()=>{
        expect(1 + 1).toBe(2);
    });
    test('can render basic React component', ()=>{
        const TestComponent = ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                children: "Hello Test"
            });
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
        expect(_react1.screen.getByText('Hello Test')).toBeInTheDocument();
    });
    test('can import heroicons', async ()=>{
        const { CogIcon } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("@heroicons/react/24/outline")));
        expect(CogIcon).toBeDefined();
    });
    test('can import framer-motion', async ()=>{
        const { motion } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("framer-motion")));
        expect(motion).toBeDefined();
    });
    test('can import contexts with mock', ()=>{
        // Mock the settings context
        jest.doMock('@/contexts/SettingsContext', ()=>({
                useSettings: ()=>({
                        settings: null,
                        loading: false,
                        error: null,
                        updateSettings: jest.fn(),
                        resetSettings: jest.fn(),
                        clearError: jest.fn()
                    })
            }));
        expect(true).toBe(true); // If we get here, the mock worked
    });
    test('can import SettingsPage component', async ()=>{
        const SettingsPageModule = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../page")));
        expect(SettingsPageModule.default).toBeDefined();
    });
    test('can render SettingsPage component', ()=>{
        // Import after mocks are set up
        const SettingsPage = require('../page').default;
        // Add console.log to see what's happening
        const originalConsoleLog = console.log;
        console.log = jest.fn();
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(SettingsPage, {}));
        // Check if our mock was called
        expect(console.log).toHaveBeenCalledWith('Mock useSettings called');
        // Restore console.log
        console.log = originalConsoleLog;
        // Debug: log the actual DOM
        console.log('Rendered DOM:', document.body.innerHTML);
        expect(_react1.screen.getByText('Settings')).toBeInTheDocument();
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXZhbi9EZXNrdG9wL0Rldm9wcy1hcHAtZGV2LWN1cnNvci9mcm9udGVuZC9zcmMvYXBwL3NldHRpbmdzL19fdGVzdHNfXy9kZWJ1Zy50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4gfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcblxuLy8gTW9jayBhbGwgZGVwZW5kZW5jaWVzIGJlZm9yZSBpbXBvcnRpbmcgdGhlIGNvbXBvbmVudFxuamVzdC5tb2NrKCdAL2NvbnRleHRzL1NldHRpbmdzQ29udGV4dCcsICgpID0+ICh7XG4gIHVzZVNldHRpbmdzOiAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ01vY2sgdXNlU2V0dGluZ3MgY2FsbGVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgIGlkOiAnMScsXG4gICAgICAgIHVzZXJJZDogJ3VzZXIxJyxcbiAgICAgICAgbm90aWZpY2F0aW9uczoge1xuICAgICAgICAgIGVtYWlsTm90aWZpY2F0aW9uczogdHJ1ZSxcbiAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uczogZmFsc2UsXG4gICAgICAgICAgZGVwbG95bWVudEFsZXJ0czogdHJ1ZSxcbiAgICAgICAgICBwZXJmb3JtYW5jZUFsZXJ0czogZmFsc2UsXG4gICAgICAgICAgc2VjdXJpdHlBbGVydHM6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICB0aGVtZTogJ2xpZ2h0JyxcbiAgICAgICAgICBkYXNoYm9hcmRMYXlvdXQ6ICdncmlkJyxcbiAgICAgICAgICBtZXRyaWNzVGltZVJhbmdlOiAnMjRoJyxcbiAgICAgICAgICBjb21wYWN0VmlldzogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGludGVncmF0aW9uczoge1xuICAgICAgICAgIGdpdGh1YkVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgZ2l0aHViUmVwb3NpdG9yaWVzOiBbJ3VzZXIvcmVwbzEnLCAndXNlci9yZXBvMiddLFxuICAgICAgICAgIHNsYWNrRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgc2xhY2tDaGFubmVsOiAnI2Rldm9wcycsXG4gICAgICAgICAgamlyYUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIGppcmFQcm9qZWN0OiAnT1BTJyxcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlZEF0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgfSxcbiAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB1cGRhdGVTZXR0aW5nczogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCksXG4gICAgICByZXNldFNldHRpbmdzOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKSxcbiAgICAgIGNsZWFyRXJyb3I6IGplc3QuZm4oKSxcbiAgICB9O1xuICB9LFxufSkpO1xuXG5qZXN0Lm1vY2soJ0AvY29tcG9uZW50cy9hdXRoL3dpdGhBdXRoJywgKCkgPT4gKHtcbiAgd2l0aEF1dGg6IChDb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IENvbXBvbmVudCxcbn0pKTtcblxuamVzdC5tb2NrKCdAL2NvbXBvbmVudHMvc2V0dGluZ3MvR2l0SHViUmVwb01vZGFsJywgKCkgPT4gKHtcbiAgR2l0SHViUmVwb01vZGFsOiAoKSA9PiBudWxsLFxufSkpO1xuXG5qZXN0Lm1vY2soJ0AvY29tcG9uZW50cy9zZXR0aW5ncy9UaGVtZVNlbGVjdG9yJywgKCkgPT4gKHtcbiAgVGhlbWVTZWxlY3RvcjogKCkgPT4gPGRpdiBkYXRhLXRlc3RpZD1cInRoZW1lLXNlbGVjdG9yXCI+VGhlbWUgU2VsZWN0b3I8L2Rpdj4sXG59KSk7XG5cbmplc3QubW9jaygnZnJhbWVyLW1vdGlvbicsICgpID0+ICh7XG4gIG1vdGlvbjoge1xuICAgIGRpdjogKHsgY2hpbGRyZW4sIC4uLnByb3BzIH06IGFueSkgPT4gPGRpdiB7Li4ucHJvcHN9PntjaGlsZHJlbn08L2Rpdj4sXG4gICAgYnV0dG9uOiAoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfTogYW55KSA9PiA8YnV0dG9uIHsuLi5wcm9wc30+e2NoaWxkcmVufTwvYnV0dG9uPixcbiAgICBzZWN0aW9uOiAoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfTogYW55KSA9PiA8c2VjdGlvbiB7Li4ucHJvcHN9PntjaGlsZHJlbn08L3NlY3Rpb24+LFxuICB9LFxuICBBbmltYXRlUHJlc2VuY2U6ICh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSA9PiA8PntjaGlsZHJlbn08Lz4sXG59KSk7XG5cbmplc3QubW9jaygnQGhlcm9pY29ucy9yZWFjdC8yNC9vdXRsaW5lJywgKCkgPT4ge1xuICBjb25zdCBNb2NrSWNvbiA9ICh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfTogYW55KSA9PiAoXG4gICAgPHN2ZyBjbGFzc05hbWU9e2NsYXNzTmFtZX0gey4uLnByb3BzfSBkYXRhLXRlc3RpZD1cIm1vY2staWNvblwiPlxuICAgICAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCIxMFwiIC8+XG4gICAgPC9zdmc+XG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBDb2dJY29uOiBNb2NrSWNvbixcbiAgICBDaGVja0ljb246IE1vY2tJY29uLFxuICAgIEV4Y2xhbWF0aW9uVHJpYW5nbGVJY29uOiBNb2NrSWNvbixcbiAgICBTd2F0Y2hJY29uOiBNb2NrSWNvbixcbiAgICBCZWxsSWNvbjogTW9ja0ljb24sXG4gICAgQ29kZUJyYWNrZXRJY29uOiBNb2NrSWNvbixcbiAgICBBcnJvd1BhdGhJY29uOiBNb2NrSWNvbixcbiAgICBDaGVja0NpcmNsZUljb246IE1vY2tJY29uLFxuICAgIFhNYXJrSWNvbjogTW9ja0ljb24sXG4gIH07XG59KTtcblxuamVzdC5tb2NrKCdAL3V0aWxzL2NuJywgKCkgPT4gKHtcbiAgY246ICguLi5jbGFzc2VzOiBhbnlbXSkgPT4gY2xhc3Nlcy5maWx0ZXIoQm9vbGVhbikuam9pbignICcpLFxufSkpO1xuXG4vLyBUZXN0IGltcG9ydHMgc3RlcCBieSBzdGVwXG5kZXNjcmliZSgnRGVidWcgVGVzdHMnLCAoKSA9PiB7XG4gIHRlc3QoJ2Jhc2ljIHRlc3Qgd29ya3MnLCAoKSA9PiB7XG4gICAgZXhwZWN0KDEgKyAxKS50b0JlKDIpO1xuICB9KTtcblxuICB0ZXN0KCdjYW4gcmVuZGVyIGJhc2ljIFJlYWN0IGNvbXBvbmVudCcsICgpID0+IHtcbiAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4gPGRpdj5IZWxsbyBUZXN0PC9kaXY+O1xuICAgIHJlbmRlcig8VGVzdENvbXBvbmVudCAvPik7XG4gICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0hlbGxvIFRlc3QnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgfSk7XG5cbiAgdGVzdCgnY2FuIGltcG9ydCBoZXJvaWNvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBDb2dJY29uIH0gPSBhd2FpdCBpbXBvcnQoJ0BoZXJvaWNvbnMvcmVhY3QvMjQvb3V0bGluZScpO1xuICAgIGV4cGVjdChDb2dJY29uKS50b0JlRGVmaW5lZCgpO1xuICB9KTtcblxuICB0ZXN0KCdjYW4gaW1wb3J0IGZyYW1lci1tb3Rpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBtb3Rpb24gfSA9IGF3YWl0IGltcG9ydCgnZnJhbWVyLW1vdGlvbicpO1xuICAgIGV4cGVjdChtb3Rpb24pLnRvQmVEZWZpbmVkKCk7XG4gIH0pO1xuXG4gIHRlc3QoJ2NhbiBpbXBvcnQgY29udGV4dHMgd2l0aCBtb2NrJywgKCkgPT4ge1xuICAgIC8vIE1vY2sgdGhlIHNldHRpbmdzIGNvbnRleHRcbiAgICBqZXN0LmRvTW9jaygnQC9jb250ZXh0cy9TZXR0aW5nc0NvbnRleHQnLCAoKSA9PiAoe1xuICAgICAgdXNlU2V0dGluZ3M6ICgpID0+ICh7XG4gICAgICAgIHNldHRpbmdzOiBudWxsLFxuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIHVwZGF0ZVNldHRpbmdzOiBqZXN0LmZuKCksXG4gICAgICAgIHJlc2V0U2V0dGluZ3M6IGplc3QuZm4oKSxcbiAgICAgICAgY2xlYXJFcnJvcjogamVzdC5mbigpLFxuICAgICAgfSksXG4gICAgfSkpO1xuICAgIFxuICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpOyAvLyBJZiB3ZSBnZXQgaGVyZSwgdGhlIG1vY2sgd29ya2VkXG4gIH0pO1xuXG4gIHRlc3QoJ2NhbiBpbXBvcnQgU2V0dGluZ3NQYWdlIGNvbXBvbmVudCcsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBTZXR0aW5nc1BhZ2VNb2R1bGUgPSBhd2FpdCBpbXBvcnQoJy4uL3BhZ2UnKTtcbiAgICBleHBlY3QoU2V0dGluZ3NQYWdlTW9kdWxlLmRlZmF1bHQpLnRvQmVEZWZpbmVkKCk7XG4gIH0pO1xuXG4gIHRlc3QoJ2NhbiByZW5kZXIgU2V0dGluZ3NQYWdlIGNvbXBvbmVudCcsICgpID0+IHtcbiAgICAvLyBJbXBvcnQgYWZ0ZXIgbW9ja3MgYXJlIHNldCB1cFxuICAgIGNvbnN0IFNldHRpbmdzUGFnZSA9IHJlcXVpcmUoJy4uL3BhZ2UnKS5kZWZhdWx0O1xuICAgIFxuICAgIC8vIEFkZCBjb25zb2xlLmxvZyB0byBzZWUgd2hhdCdzIGhhcHBlbmluZ1xuICAgIGNvbnN0IG9yaWdpbmFsQ29uc29sZUxvZyA9IGNvbnNvbGUubG9nO1xuICAgIGNvbnNvbGUubG9nID0gamVzdC5mbigpO1xuICAgIFxuICAgIHJlbmRlcig8U2V0dGluZ3NQYWdlIC8+KTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBvdXIgbW9jayB3YXMgY2FsbGVkXG4gICAgZXhwZWN0KGNvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnTW9jayB1c2VTZXR0aW5ncyBjYWxsZWQnKTtcbiAgICBcbiAgICAvLyBSZXN0b3JlIGNvbnNvbGUubG9nXG4gICAgY29uc29sZS5sb2cgPSBvcmlnaW5hbENvbnNvbGVMb2c7XG4gICAgXG4gICAgLy8gRGVidWc6IGxvZyB0aGUgYWN0dWFsIERPTVxuICAgIGNvbnNvbGUubG9nKCdSZW5kZXJlZCBET006JywgZG9jdW1lbnQuYm9keS5pbm5lckhUTUwpO1xuICAgIFxuICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdTZXR0aW5ncycpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICB9KTtcbn0pOyAiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJ1c2VTZXR0aW5ncyIsImNvbnNvbGUiLCJsb2ciLCJzZXR0aW5ncyIsImlkIiwidXNlcklkIiwibm90aWZpY2F0aW9ucyIsImVtYWlsTm90aWZpY2F0aW9ucyIsInB1c2hOb3RpZmljYXRpb25zIiwiZGVwbG95bWVudEFsZXJ0cyIsInBlcmZvcm1hbmNlQWxlcnRzIiwic2VjdXJpdHlBbGVydHMiLCJkaXNwbGF5IiwidGhlbWUiLCJkYXNoYm9hcmRMYXlvdXQiLCJtZXRyaWNzVGltZVJhbmdlIiwiY29tcGFjdFZpZXciLCJpbnRlZ3JhdGlvbnMiLCJnaXRodWJFbmFibGVkIiwiZ2l0aHViUmVwb3NpdG9yaWVzIiwic2xhY2tFbmFibGVkIiwic2xhY2tDaGFubmVsIiwiamlyYUVuYWJsZWQiLCJqaXJhUHJvamVjdCIsInVwZGF0ZWRBdCIsImxvYWRpbmciLCJlcnJvciIsInVwZGF0ZVNldHRpbmdzIiwiZm4iLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInVuZGVmaW5lZCIsInJlc2V0U2V0dGluZ3MiLCJjbGVhckVycm9yIiwid2l0aEF1dGgiLCJDb21wb25lbnQiLCJHaXRIdWJSZXBvTW9kYWwiLCJUaGVtZVNlbGVjdG9yIiwiZGl2IiwiZGF0YS10ZXN0aWQiLCJtb3Rpb24iLCJjaGlsZHJlbiIsInByb3BzIiwiYnV0dG9uIiwic2VjdGlvbiIsIkFuaW1hdGVQcmVzZW5jZSIsIk1vY2tJY29uIiwiY2xhc3NOYW1lIiwic3ZnIiwiY2lyY2xlIiwiY3giLCJjeSIsInIiLCJDb2dJY29uIiwiQ2hlY2tJY29uIiwiRXhjbGFtYXRpb25UcmlhbmdsZUljb24iLCJTd2F0Y2hJY29uIiwiQmVsbEljb24iLCJDb2RlQnJhY2tldEljb24iLCJBcnJvd1BhdGhJY29uIiwiQ2hlY2tDaXJjbGVJY29uIiwiWE1hcmtJY29uIiwiY24iLCJjbGFzc2VzIiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJkZXNjcmliZSIsInRlc3QiLCJleHBlY3QiLCJ0b0JlIiwiVGVzdENvbXBvbmVudCIsInJlbmRlciIsInNjcmVlbiIsImdldEJ5VGV4dCIsInRvQmVJblRoZURvY3VtZW50IiwidG9CZURlZmluZWQiLCJkb01vY2siLCJTZXR0aW5nc1BhZ2VNb2R1bGUiLCJkZWZhdWx0IiwiU2V0dGluZ3NQYWdlIiwicmVxdWlyZSIsIm9yaWdpbmFsQ29uc29sZUxvZyIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwiZG9jdW1lbnQiLCJib2R5IiwiaW5uZXJIVE1MIl0sIm1hcHBpbmdzIjoiO0FBR0EsdURBQXVEO0FBQ3ZEQSxLQUFLQyxJQUFJLENBQUMsOEJBQThCLElBQU8sQ0FBQTtRQUM3Q0MsYUFBYTtZQUNYQyxRQUFRQyxHQUFHLENBQUM7WUFDWixPQUFPO2dCQUNMQyxVQUFVO29CQUNSQyxJQUFJO29CQUNKQyxRQUFRO29CQUNSQyxlQUFlO3dCQUNiQyxvQkFBb0I7d0JBQ3BCQyxtQkFBbUI7d0JBQ25CQyxrQkFBa0I7d0JBQ2xCQyxtQkFBbUI7d0JBQ25CQyxnQkFBZ0I7b0JBQ2xCO29CQUNBQyxTQUFTO3dCQUNQQyxPQUFPO3dCQUNQQyxpQkFBaUI7d0JBQ2pCQyxrQkFBa0I7d0JBQ2xCQyxhQUFhO29CQUNmO29CQUNBQyxjQUFjO3dCQUNaQyxlQUFlO3dCQUNmQyxvQkFBb0I7NEJBQUM7NEJBQWM7eUJBQWE7d0JBQ2hEQyxjQUFjO3dCQUNkQyxjQUFjO3dCQUNkQyxhQUFhO3dCQUNiQyxhQUFhO29CQUNmO29C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