a25e9548d7a3b87de7ea0694949da0ec
/**
 * Authentication context for managing user session state.
 * Provides authentication state, user data, and auth methods to components.
 */ 'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AuthProvider: function() {
        return AuthProvider;
    },
    default: function() {
        return _default;
    },
    useAuth: function() {
        return useAuth;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Initial state
const initialState = {
    isAuthenticated: false,
    isLoading: false,
    user: null,
    tokens: null,
    error: null
};
// Auth reducer
function authReducer(state, action) {
    switch(action.type){
        case 'AUTH_START':
            return {
                ...state,
                isLoading: true,
                error: null
            };
        case 'AUTH_SUCCESS':
            return {
                ...state,
                isAuthenticated: true,
                isLoading: false,
                user: action.payload.user,
                tokens: action.payload.tokens,
                error: null
            };
        case 'AUTH_FAILURE':
            return {
                ...state,
                isAuthenticated: false,
                isLoading: false,
                user: null,
                tokens: null,
                error: action.payload
            };
        case 'AUTH_LOGOUT':
            return {
                ...initialState
            };
        case 'AUTH_REFRESH_SUCCESS':
            return {
                ...state,
                tokens: action.payload,
                error: null
            };
        case 'AUTH_UPDATE_USER':
            return {
                ...state,
                user: action.payload
            };
        default:
            return state;
    }
}
// Create context
const AuthContext = /*#__PURE__*/ (0, _react.createContext)(undefined);
// Storage keys
const STORAGE_KEYS = {
    ACCESS_TOKEN: 'opsight_access_token',
    REFRESH_TOKEN: 'opsight_refresh_token',
    USER_DATA: 'opsight_user_data'
};
// API base URL - Use process.env for Jest compatibility
const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:8000/api/v1';
const AuthProvider = ({ children })=>{
    const [state, dispatch] = (0, _react.useReducer)(authReducer, initialState);
    /**
   * Initialize authentication state from stored tokens on app start.
   */ (0, _react.useEffect)(()=>{
        const initializeAuth = async ()=>{
            const accessToken = localStorage.getItem(STORAGE_KEYS.ACCESS_TOKEN);
            const refreshToken = localStorage.getItem(STORAGE_KEYS.REFRESH_TOKEN);
            const userData = localStorage.getItem(STORAGE_KEYS.USER_DATA);
            if (accessToken && userData) {
                try {
                    const user = JSON.parse(userData);
                    const tokens = {
                        access_token: accessToken,
                        refresh_token: refreshToken || undefined,
                        token_type: 'bearer'
                    };
                    dispatch({
                        type: 'AUTH_SUCCESS',
                        payload: {
                            user,
                            tokens
                        }
                    });
                    // Verify token is still valid by fetching current user
                    await getCurrentUser();
                } catch (error) {
                    // Reason: Clear invalid stored data
                    clearStoredAuth();
                }
            }
        };
        initializeAuth();
    }, []);
    /**
   * Clear stored authentication data from localStorage.
   */ const clearStoredAuth = ()=>{
        localStorage.removeItem(STORAGE_KEYS.ACCESS_TOKEN);
        localStorage.removeItem(STORAGE_KEYS.REFRESH_TOKEN);
        localStorage.removeItem(STORAGE_KEYS.USER_DATA);
    };
    /**
   * Store authentication data in localStorage.
   */ const storeAuthData = (user, tokens)=>{
        localStorage.setItem(STORAGE_KEYS.ACCESS_TOKEN, tokens.access_token);
        if (tokens.refresh_token) {
            localStorage.setItem(STORAGE_KEYS.REFRESH_TOKEN, tokens.refresh_token);
        }
        localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(user));
    };
    /**
   * Make authenticated API request with automatic token refresh.
   */ const authenticatedFetch = async (url, options = {})=>{
        const accessToken = state.tokens?.access_token;
        if (!accessToken) {
            throw new Error('No access token available');
        }
        const response = await fetch(url, {
            ...options,
            headers: {
                ...options.headers,
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
            }
        });
        // If token expired, try to refresh
        if (response.status === 401 && state.tokens?.refresh_token) {
            try {
                await refreshToken();
                // Retry the request with new token
                return fetch(url, {
                    ...options,
                    headers: {
                        ...options.headers,
                        'Authorization': `Bearer ${state.tokens?.access_token}`,
                        'Content-Type': 'application/json'
                    }
                });
            } catch (refreshError) {
                // Refresh failed, logout user
                await logout();
                throw new Error('Session expired. Please log in again.');
            }
        }
        return response;
    };
    /**
   * Login with GitHub OAuth code.
   */ const login = async (code, state_param)=>{
        dispatch({
            type: 'AUTH_START'
        });
        try {
            const response = await fetch(`${API_BASE_URL}/auth/login/github`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    code,
                    state: state_param
                })
            });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Login failed');
            }
            const tokens = await response.json();
            // Get user data
            const userResponse = await fetch(`${API_BASE_URL}/auth/me`, {
                headers: {
                    'Authorization': `Bearer ${tokens.access_token}`
                }
            });
            if (!userResponse.ok) {
                throw new Error('Failed to fetch user data');
            }
            const user = await userResponse.json();
            // Store auth data
            storeAuthData(user, tokens);
            dispatch({
                type: 'AUTH_SUCCESS',
                payload: {
                    user,
                    tokens
                }
            });
        } catch (error) {
            const message = error instanceof Error ? error.message : 'Login failed';
            dispatch({
                type: 'AUTH_FAILURE',
                payload: message
            });
            throw error;
        }
    };
    /**
   * Logout current user.
   */ const logout = async ()=>{
        try {
            // Call logout endpoint if authenticated
            if (state.tokens?.access_token) {
                await authenticatedFetch(`${API_BASE_URL}/auth/logout`, {
                    method: 'POST'
                });
            }
        } catch (error) {
            // Log error but continue with logout
            console.warn('Logout API call failed:', error);
        } finally{
            // Always clear local state and storage
            clearStoredAuth();
            dispatch({
                type: 'AUTH_LOGOUT'
            });
        }
    };
    /**
   * Refresh access token using refresh token.
   */ const refreshToken = async ()=>{
        const refresh_token = state.tokens?.refresh_token;
        if (!refresh_token) {
            throw new Error('No refresh token available');
        }
        try {
            const response = await fetch(`${API_BASE_URL}/auth/refresh`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    refresh_token
                })
            });
            if (!response.ok) {
                throw new Error('Token refresh failed');
            }
            const tokens = await response.json();
            // Update stored tokens
            localStorage.setItem(STORAGE_KEYS.ACCESS_TOKEN, tokens.access_token);
            if (tokens.refresh_token) {
                localStorage.setItem(STORAGE_KEYS.REFRESH_TOKEN, tokens.refresh_token);
            }
            dispatch({
                type: 'AUTH_REFRESH_SUCCESS',
                payload: tokens
            });
        } catch (error) {
            // Refresh failed, logout user
            await logout();
            throw error;
        }
    };
    /**
   * Get current user data from API.
   */ const getCurrentUser = async ()=>{
        try {
            const response = await authenticatedFetch(`${API_BASE_URL}/auth/me`);
            if (!response.ok) {
                throw new Error('Failed to fetch user data');
            }
            const user = await response.json();
            // Update stored user data
            localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(user));
            dispatch({
                type: 'AUTH_UPDATE_USER',
                payload: user
            });
        } catch (error) {
            console.error('Failed to get current user:', error);
            throw error;
        }
    };
    /**
   * Check if user has specific permission.
   */ const hasPermission = (permission, organizationId)=>{
        if (!state.user || !state.isAuthenticated) return false;
        // Superuser has all permissions
        if (state.user.is_superuser) return true;
        // Check user permissions
        if (state.user.permissions) {
            return state.user.permissions.some((p)=>p.name === permission && (!organizationId || !p.organization_id || p.organization_id === organizationId));
        }
        // Check role permissions
        if (state.user.roles) {
            return state.user.roles.some((role)=>role.permissions.some((p)=>p.name === permission && (!organizationId || !p.organization_id || p.organization_id === organizationId)));
        }
        return false;
    };
    /**
   * Check if user has specific role.
   */ const hasRole = (role)=>{
        if (!state.user || !state.isAuthenticated) return false;
        return state.user.roles?.some((r)=>r.name === role) || false;
    };
    /**
   * Check if user has any of the specified roles.
   */ const hasAnyRole = (roles)=>{
        if (!state.user || !state.isAuthenticated) return false;
        return roles.some((role)=>hasRole(role));
    };
    /**
   * Check if user has any of the specified permissions.
   */ const hasAnyPermission = (permissions)=>{
        if (!state.user || !state.isAuthenticated) return false;
        return permissions.some((permission)=>hasPermission(permission));
    };
    /**
   * Get all user permissions (direct + role-based).
   */ const getUserPermissions = ()=>{
        if (!state.user || !state.isAuthenticated) return [];
        const permissions = new Map();
        // Add direct permissions
        if (state.user.permissions) {
            state.user.permissions.forEach((p)=>permissions.set(p.id, p));
        }
        // Add role permissions
        if (state.user.roles) {
            state.user.roles.forEach((role)=>{
                role.permissions.forEach((p)=>permissions.set(p.id, p));
            });
        }
        return Array.from(permissions.values());
    };
    /**
   * Get all user roles.
   */ const getUserRoles = ()=>{
        if (!state.user || !state.isAuthenticated) return [];
        return state.user.roles || [];
    };
    /**
   * Check if user is admin (superuser or has admin role).
   */ const isAdmin = ()=>{
        if (!state.user || !state.isAuthenticated) return false;
        return state.user.is_superuser || hasRole('admin') || hasRole('organization_owner');
    };
    /**
   * Check if user can access a resource with specific action.
   */ const canAccess = (resource, action, organizationId)=>{
        if (!state.user || !state.isAuthenticated) return false;
        // Build permission name from resource and action
        const permissionName = `${action}_${resource}`;
        return hasPermission(permissionName, organizationId);
    };
    const contextValue = {
        state,
        login,
        logout,
        refreshToken,
        getCurrentUser,
        hasPermission,
        hasRole,
        hasAnyRole,
        hasAnyPermission,
        getUserPermissions,
        getUserRoles,
        isAdmin,
        canAccess
    };
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(AuthContext.Provider, {
        value: contextValue,
        children: children
    });
};
const useAuth = ()=>{
    const context = (0, _react.useContext)(AuthContext);
    if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};
const _default = AuthContext;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXZhbi9EZXNrdG9wL0Rldm9wcy1hcHAtZGV2LWN1cnNvci9mcm9udGVuZC9zcmMvY29udGV4dHMvQXV0aENvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXV0aGVudGljYXRpb24gY29udGV4dCBmb3IgbWFuYWdpbmcgdXNlciBzZXNzaW9uIHN0YXRlLlxuICogUHJvdmlkZXMgYXV0aGVudGljYXRpb24gc3RhdGUsIHVzZXIgZGF0YSwgYW5kIGF1dGggbWV0aG9kcyB0byBjb21wb25lbnRzLlxuICovXG4ndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VSZWR1Y2VyLCB1c2VFZmZlY3QsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFxuICBBUElFcnJvciwgXG4gIE5ldHdvcmtFcnJvciwgXG4gIFRva2VuRXJyb3IsIFxuICBFcnJvckxvZ2dlcixcbiAgQXBwRXJyb3IsXG4gIEVycm9yVHlwZSxcbiAgaGFuZGxlRmV0Y2hFcnJvcixcbiAgY3JlYXRlTmV0d29ya0Vycm9yIFxufSBmcm9tICcuLi91dGlscy9lcnJvckhhbmRsaW5nJztcbmltcG9ydCB7IFxuICBUb2tlblNlY3VyaXR5LCBcbiAgQ1NSRlByb3RlY3Rpb24sXG4gIElucHV0VmFsaWRhdG9yLFxuICBSYXRlTGltaXRlciBcbn0gZnJvbSAnLi4vdXRpbHMvc2VjdXJpdHknO1xuXG4vLyBUeXBlcyBmb3IgYXV0aGVudGljYXRpb24gc3RhdGVcbmludGVyZmFjZSBSb2xlIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkaXNwbGF5X25hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgcHJpb3JpdHk6IG51bWJlcjtcbiAgaXNfc3lzdGVtX3JvbGU6IGJvb2xlYW47XG4gIHBlcm1pc3Npb25zOiBQZXJtaXNzaW9uW107XG59XG5cbmludGVyZmFjZSBQZXJtaXNzaW9uIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkaXNwbGF5X25hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgaXNfc3lzdGVtX3Blcm1pc3Npb246IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IG51bWJlcjtcbiAgZ2l0aHViX2lkOiBzdHJpbmc7XG4gIGdpdGh1Yl91c2VybmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nIHwgbnVsbDtcbiAgZnVsbF9uYW1lOiBzdHJpbmcgfCBudWxsO1xuICBhdmF0YXJfdXJsOiBzdHJpbmcgfCBudWxsO1xuICBiaW86IHN0cmluZyB8IG51bGw7XG4gIGNvbXBhbnk6IHN0cmluZyB8IG51bGw7XG4gIGxvY2F0aW9uOiBzdHJpbmcgfCBudWxsO1xuICBibG9nOiBzdHJpbmcgfCBudWxsO1xuICBpc19hY3RpdmU6IGJvb2xlYW47XG4gIGlzX3N1cGVydXNlcjogYm9vbGVhbjtcbiAgY3JlYXRlZF9hdDogc3RyaW5nIHwgbnVsbDtcbiAgdXBkYXRlZF9hdDogc3RyaW5nIHwgbnVsbDtcbiAgbGFzdF9sb2dpbjogc3RyaW5nIHwgbnVsbDtcbiAgcm9sZXM/OiBSb2xlW107XG4gIHBlcm1pc3Npb25zPzogUGVybWlzc2lvbltdO1xuICBvcmdhbml6YXRpb25faWQ/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBBdXRoVG9rZW5zIHtcbiAgYWNjZXNzX3Rva2VuOiBzdHJpbmc7XG4gIHJlZnJlc2hfdG9rZW4/OiBzdHJpbmc7XG4gIHRva2VuX3R5cGU6IHN0cmluZztcbiAgZXhwaXJlc19pbj86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEF1dGhTdGF0ZSB7XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICB1c2VyOiBVc2VyIHwgbnVsbDtcbiAgdG9rZW5zOiBBdXRoVG9rZW5zIHwgbnVsbDtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG59XG5cbi8vIEF1dGggYWN0aW9uIHR5cGVzXG50eXBlIEF1dGhBY3Rpb24gPVxuICB8IHsgdHlwZTogJ0FVVEhfU1RBUlQnIH1cbiAgfCB7IHR5cGU6ICdBVVRIX1NVQ0NFU1MnOyBwYXlsb2FkOiB7IHVzZXI6IFVzZXI7IHRva2VuczogQXV0aFRva2VucyB9IH1cbiAgfCB7IHR5cGU6ICdBVVRIX0ZBSUxVUkUnOyBwYXlsb2FkOiBzdHJpbmcgfVxuICB8IHsgdHlwZTogJ0FVVEhfTE9HT1VUJyB9XG4gIHwgeyB0eXBlOiAnQVVUSF9SRUZSRVNIX1NVQ0NFU1MnOyBwYXlsb2FkOiBBdXRoVG9rZW5zIH1cbiAgfCB7IHR5cGU6ICdBVVRIX1VQREFURV9VU0VSJzsgcGF5bG9hZDogVXNlciB9O1xuXG4vLyBBdXRoIGNvbnRleHQgaW50ZXJmYWNlXG5pbnRlcmZhY2UgQXV0aENvbnRleHRUeXBlIHtcbiAgc3RhdGU6IEF1dGhTdGF0ZTtcbiAgbG9naW46IChjb2RlOiBzdHJpbmcsIHN0YXRlPzogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBsb2dvdXQ6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHJlZnJlc2hUb2tlbjogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZ2V0Q3VycmVudFVzZXI6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGhhc1Blcm1pc3Npb246IChwZXJtaXNzaW9uOiBzdHJpbmcsIG9yZ2FuaXphdGlvbklkPzogc3RyaW5nKSA9PiBib29sZWFuO1xuICBoYXNSb2xlOiAocm9sZTogc3RyaW5nKSA9PiBib29sZWFuO1xuICBoYXNBbnlSb2xlOiAocm9sZXM6IHN0cmluZ1tdKSA9PiBib29sZWFuO1xuICBoYXNBbnlQZXJtaXNzaW9uOiAocGVybWlzc2lvbnM6IHN0cmluZ1tdKSA9PiBib29sZWFuO1xuICBnZXRVc2VyUGVybWlzc2lvbnM6ICgpID0+IFBlcm1pc3Npb25bXTtcbiAgZ2V0VXNlclJvbGVzOiAoKSA9PiBSb2xlW107XG4gIGlzQWRtaW46ICgpID0+IGJvb2xlYW47XG4gIGNhbkFjY2VzczogKHJlc291cmNlOiBzdHJpbmcsIGFjdGlvbjogc3RyaW5nLCBvcmdhbml6YXRpb25JZD86IHN0cmluZykgPT4gYm9vbGVhbjtcbn1cblxuLy8gSW5pdGlhbCBzdGF0ZVxuY29uc3QgaW5pdGlhbFN0YXRlOiBBdXRoU3RhdGUgPSB7XG4gIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXG4gIGlzTG9hZGluZzogZmFsc2UsXG4gIHVzZXI6IG51bGwsXG4gIHRva2VuczogbnVsbCxcbiAgZXJyb3I6IG51bGwsXG59O1xuXG4vLyBBdXRoIHJlZHVjZXJcbmZ1bmN0aW9uIGF1dGhSZWR1Y2VyKHN0YXRlOiBBdXRoU3RhdGUsIGFjdGlvbjogQXV0aEFjdGlvbik6IEF1dGhTdGF0ZSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdBVVRIX1NUQVJUJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfTtcbiAgICBjYXNlICdBVVRIX1NVQ0NFU1MnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgdXNlcjogYWN0aW9uLnBheWxvYWQudXNlcixcbiAgICAgICAgdG9rZW5zOiBhY3Rpb24ucGF5bG9hZC50b2tlbnMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfTtcbiAgICBjYXNlICdBVVRIX0ZBSUxVUkUnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgIHRva2VuczogbnVsbCxcbiAgICAgICAgZXJyb3I6IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgfTtcbiAgICBjYXNlICdBVVRIX0xPR09VVCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbml0aWFsU3RhdGUsXG4gICAgICB9O1xuICAgIGNhc2UgJ0FVVEhfUkVGUkVTSF9TVUNDRVNTJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICB0b2tlbnM6IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH07XG4gICAgY2FzZSAnQVVUSF9VUERBVEVfVVNFUic6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdXNlcjogYWN0aW9uLnBheWxvYWQsXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuLy8gQ3JlYXRlIGNvbnRleHRcbmNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG5cbi8vIFN0b3JhZ2Uga2V5c1xuY29uc3QgU1RPUkFHRV9LRVlTID0ge1xuICBBQ0NFU1NfVE9LRU46ICdvcHNpZ2h0X2FjY2Vzc190b2tlbicsXG4gIFJFRlJFU0hfVE9LRU46ICdvcHNpZ2h0X3JlZnJlc2hfdG9rZW4nLFxuICBVU0VSX0RBVEE6ICdvcHNpZ2h0X3VzZXJfZGF0YScsXG59IGFzIGNvbnN0O1xuXG4vLyBBUEkgYmFzZSBVUkwgLSBVc2UgcHJvY2Vzcy5lbnYgZm9yIEplc3QgY29tcGF0aWJpbGl0eVxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpL3YxJztcblxuLyoqXG4gKiBBdXRoZW50aWNhdGlvbiBQcm92aWRlciBDb21wb25lbnRcbiAqIFxuICogTWFuYWdlcyBhdXRoZW50aWNhdGlvbiBzdGF0ZSBhbmQgcHJvdmlkZXMgYXV0aCBtZXRob2RzIHRvIGNoaWxkIGNvbXBvbmVudHMuXG4gKiBIYW5kbGVzIHRva2VuIHBlcnNpc3RlbmNlLCBhdXRvbWF0aWMgcmVmcmVzaCwgYW5kIHNlc3Npb24gcmVzdG9yYXRpb24uXG4gKiBcbiAqIEBwYXJhbSBjaGlsZHJlbiAtIENoaWxkIGNvbXBvbmVudHMgdGhhdCBuZWVkIGFjY2VzcyB0byBhdXRoIGNvbnRleHRcbiAqL1xuZXhwb3J0IGNvbnN0IEF1dGhQcm92aWRlcjogUmVhY3QuRkM8eyBjaGlsZHJlbjogUmVhY3ROb2RlIH0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IHVzZVJlZHVjZXIoYXV0aFJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYXV0aGVudGljYXRpb24gc3RhdGUgZnJvbSBzdG9yZWQgdG9rZW5zIG9uIGFwcCBzdGFydC5cbiAgICovXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZUF1dGggPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZUy5BQ0NFU1NfVE9LRU4pO1xuICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVlTLlJFRlJFU0hfVE9LRU4pO1xuICAgICAgY29uc3QgdXNlckRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWVMuVVNFUl9EQVRBKTtcblxuICAgICAgaWYgKGFjY2Vzc1Rva2VuICYmIHVzZXJEYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdXNlciA9IEpTT04ucGFyc2UodXNlckRhdGEpO1xuICAgICAgICAgIGNvbnN0IHRva2VucyA9IHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG9rZW5fdHlwZTogJ2JlYXJlcicsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdBVVRIX1NVQ0NFU1MnLFxuICAgICAgICAgICAgcGF5bG9hZDogeyB1c2VyLCB0b2tlbnMgfSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFZlcmlmeSB0b2tlbiBpcyBzdGlsbCB2YWxpZCBieSBmZXRjaGluZyBjdXJyZW50IHVzZXJcbiAgICAgICAgICBhd2FpdCBnZXRDdXJyZW50VXNlcigpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIFJlYXNvbjogQ2xlYXIgaW52YWxpZCBzdG9yZWQgZGF0YVxuICAgICAgICAgIGNsZWFyU3RvcmVkQXV0aCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGluaXRpYWxpemVBdXRoKCk7XG4gIH0sIFtdKTtcblxuICAvKipcbiAgICogQ2xlYXIgc3RvcmVkIGF1dGhlbnRpY2F0aW9uIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2UuXG4gICAqL1xuICBjb25zdCBjbGVhclN0b3JlZEF1dGggPSAoKTogdm9pZCA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oU1RPUkFHRV9LRVlTLkFDQ0VTU19UT0tFTik7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oU1RPUkFHRV9LRVlTLlJFRlJFU0hfVE9LRU4pO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfS0VZUy5VU0VSX0RBVEEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9yZSBhdXRoZW50aWNhdGlvbiBkYXRhIGluIGxvY2FsU3RvcmFnZS5cbiAgICovXG4gIGNvbnN0IHN0b3JlQXV0aERhdGEgPSAodXNlcjogVXNlciwgdG9rZW5zOiBBdXRoVG9rZW5zKTogdm9pZCA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVlTLkFDQ0VTU19UT0tFTiwgdG9rZW5zLmFjY2Vzc190b2tlbik7XG4gICAgaWYgKHRva2Vucy5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuUkVGUkVTSF9UT0tFTiwgdG9rZW5zLnJlZnJlc2hfdG9rZW4pO1xuICAgIH1cbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuVVNFUl9EQVRBLCBKU09OLnN0cmluZ2lmeSh1c2VyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2UgYXV0aGVudGljYXRlZCBBUEkgcmVxdWVzdCB3aXRoIGF1dG9tYXRpYyB0b2tlbiByZWZyZXNoLlxuICAgKi9cbiAgY29uc3QgYXV0aGVudGljYXRlZEZldGNoID0gYXN5bmMgKFxuICAgIHVybDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge31cbiAgKTogUHJvbWlzZTxSZXNwb25zZT4gPT4ge1xuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gc3RhdGUudG9rZW5zPy5hY2Nlc3NfdG9rZW47XG4gICAgXG4gICAgaWYgKCFhY2Nlc3NUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MgdG9rZW4gYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBJZiB0b2tlbiBleHBpcmVkLCB0cnkgdG8gcmVmcmVzaFxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSAmJiBzdGF0ZS50b2tlbnM/LnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHJlZnJlc2hUb2tlbigpO1xuICAgICAgICAvLyBSZXRyeSB0aGUgcmVxdWVzdCB3aXRoIG5ldyB0b2tlblxuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtzdGF0ZS50b2tlbnM/LmFjY2Vzc190b2tlbn1gLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKHJlZnJlc2hFcnJvcikge1xuICAgICAgICAvLyBSZWZyZXNoIGZhaWxlZCwgbG9nb3V0IHVzZXJcbiAgICAgICAgYXdhaXQgbG9nb3V0KCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2Vzc2lvbiBleHBpcmVkLiBQbGVhc2UgbG9nIGluIGFnYWluLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcblxuICAvKipcbiAgICogTG9naW4gd2l0aCBHaXRIdWIgT0F1dGggY29kZS5cbiAgICovXG4gIGNvbnN0IGxvZ2luID0gYXN5bmMgKGNvZGU6IHN0cmluZywgc3RhdGVfcGFyYW0/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdBVVRIX1NUQVJUJyB9KTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXV0aC9sb2dpbi9naXRodWJgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgc3RhdGU6IHN0YXRlX3BhcmFtLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZGV0YWlsIHx8ICdMb2dpbiBmYWlsZWQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9rZW5zOiBBdXRoVG9rZW5zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBHZXQgdXNlciBkYXRhXG4gICAgICBjb25zdCB1c2VyUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2F1dGgvbWVgLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbnMuYWNjZXNzX3Rva2VufWAsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgaWYgKCF1c2VyUmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggdXNlciBkYXRhJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVzZXI6IFVzZXIgPSBhd2FpdCB1c2VyUmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBTdG9yZSBhdXRoIGRhdGFcbiAgICAgIHN0b3JlQXV0aERhdGEodXNlciwgdG9rZW5zKTtcblxuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnQVVUSF9TVUNDRVNTJyxcbiAgICAgICAgcGF5bG9hZDogeyB1c2VyLCB0b2tlbnMgfSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnTG9naW4gZmFpbGVkJztcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ0FVVEhfRkFJTFVSRScsIHBheWxvYWQ6IG1lc3NhZ2UgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExvZ291dCBjdXJyZW50IHVzZXIuXG4gICAqL1xuICBjb25zdCBsb2dvdXQgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENhbGwgbG9nb3V0IGVuZHBvaW50IGlmIGF1dGhlbnRpY2F0ZWRcbiAgICAgIGlmIChzdGF0ZS50b2tlbnM/LmFjY2Vzc190b2tlbikge1xuICAgICAgICBhd2FpdCBhdXRoZW50aWNhdGVkRmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hdXRoL2xvZ291dGAsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIExvZyBlcnJvciBidXQgY29udGludWUgd2l0aCBsb2dvdXRcbiAgICAgIGNvbnNvbGUud2FybignTG9nb3V0IEFQSSBjYWxsIGZhaWxlZDonLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIEFsd2F5cyBjbGVhciBsb2NhbCBzdGF0ZSBhbmQgc3RvcmFnZVxuICAgICAgY2xlYXJTdG9yZWRBdXRoKCk7XG4gICAgICBkaXNwYXRjaCh7IHR5cGU6ICdBVVRIX0xPR09VVCcgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGFjY2VzcyB0b2tlbiB1c2luZyByZWZyZXNoIHRva2VuLlxuICAgKi9cbiAgY29uc3QgcmVmcmVzaFRva2VuID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGNvbnN0IHJlZnJlc2hfdG9rZW4gPSBzdGF0ZS50b2tlbnM/LnJlZnJlc2hfdG9rZW47XG4gICAgXG4gICAgaWYgKCFyZWZyZXNoX3Rva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlZnJlc2ggdG9rZW4gYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hdXRoL3JlZnJlc2hgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHJlZnJlc2hfdG9rZW4sXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiByZWZyZXNoIGZhaWxlZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2tlbnM6IEF1dGhUb2tlbnMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBzdG9yZWQgdG9rZW5zXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuQUNDRVNTX1RPS0VOLCB0b2tlbnMuYWNjZXNzX3Rva2VuKTtcbiAgICAgIGlmICh0b2tlbnMucmVmcmVzaF90b2tlbikge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuUkVGUkVTSF9UT0tFTiwgdG9rZW5zLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdBVVRIX1JFRlJFU0hfU1VDQ0VTUycsXG4gICAgICAgIHBheWxvYWQ6IHRva2VucyxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBSZWZyZXNoIGZhaWxlZCwgbG9nb3V0IHVzZXJcbiAgICAgIGF3YWl0IGxvZ291dCgpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB1c2VyIGRhdGEgZnJvbSBBUEkuXG4gICAqL1xuICBjb25zdCBnZXRDdXJyZW50VXNlciA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGVkRmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hdXRoL21lYCk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggdXNlciBkYXRhJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVzZXI6IFVzZXIgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBzdG9yZWQgdXNlciBkYXRhXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuVVNFUl9EQVRBLCBKU09OLnN0cmluZ2lmeSh1c2VyKSk7XG5cbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ0FVVEhfVVBEQVRFX1VTRVInLFxuICAgICAgICBwYXlsb2FkOiB1c2VyLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgY3VycmVudCB1c2VyOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdXNlciBoYXMgc3BlY2lmaWMgcGVybWlzc2lvbi5cbiAgICovXG4gIGNvbnN0IGhhc1Blcm1pc3Npb24gPSAocGVybWlzc2lvbjogc3RyaW5nLCBvcmdhbml6YXRpb25JZD86IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghc3RhdGUudXNlciB8fCAhc3RhdGUuaXNBdXRoZW50aWNhdGVkKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gU3VwZXJ1c2VyIGhhcyBhbGwgcGVybWlzc2lvbnNcbiAgICBpZiAoc3RhdGUudXNlci5pc19zdXBlcnVzZXIpIHJldHVybiB0cnVlO1xuICAgIFxuICAgIC8vIENoZWNrIHVzZXIgcGVybWlzc2lvbnNcbiAgICBpZiAoc3RhdGUudXNlci5wZXJtaXNzaW9ucykge1xuICAgICAgcmV0dXJuIHN0YXRlLnVzZXIucGVybWlzc2lvbnMuc29tZShwID0+IFxuICAgICAgICBwLm5hbWUgPT09IHBlcm1pc3Npb24gJiYgXG4gICAgICAgICghb3JnYW5pemF0aW9uSWQgfHwgIXAub3JnYW5pemF0aW9uX2lkIHx8IHAub3JnYW5pemF0aW9uX2lkID09PSBvcmdhbml6YXRpb25JZClcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIHJvbGUgcGVybWlzc2lvbnNcbiAgICBpZiAoc3RhdGUudXNlci5yb2xlcykge1xuICAgICAgcmV0dXJuIHN0YXRlLnVzZXIucm9sZXMuc29tZShyb2xlID0+IFxuICAgICAgICByb2xlLnBlcm1pc3Npb25zLnNvbWUocCA9PiBcbiAgICAgICAgICBwLm5hbWUgPT09IHBlcm1pc3Npb24gJiYgXG4gICAgICAgICAgKCFvcmdhbml6YXRpb25JZCB8fCAhcC5vcmdhbml6YXRpb25faWQgfHwgcC5vcmdhbml6YXRpb25faWQgPT09IG9yZ2FuaXphdGlvbklkKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHVzZXIgaGFzIHNwZWNpZmljIHJvbGUuXG4gICAqL1xuICBjb25zdCBoYXNSb2xlID0gKHJvbGU6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghc3RhdGUudXNlciB8fCAhc3RhdGUuaXNBdXRoZW50aWNhdGVkKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgcmV0dXJuIHN0YXRlLnVzZXIucm9sZXM/LnNvbWUociA9PiByLm5hbWUgPT09IHJvbGUpIHx8IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB1c2VyIGhhcyBhbnkgb2YgdGhlIHNwZWNpZmllZCByb2xlcy5cbiAgICovXG4gIGNvbnN0IGhhc0FueVJvbGUgPSAocm9sZXM6IHN0cmluZ1tdKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFzdGF0ZS51c2VyIHx8ICFzdGF0ZS5pc0F1dGhlbnRpY2F0ZWQpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICByZXR1cm4gcm9sZXMuc29tZShyb2xlID0+IGhhc1JvbGUocm9sZSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB1c2VyIGhhcyBhbnkgb2YgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9ucy5cbiAgICovXG4gIGNvbnN0IGhhc0FueVBlcm1pc3Npb24gPSAocGVybWlzc2lvbnM6IHN0cmluZ1tdKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFzdGF0ZS51c2VyIHx8ICFzdGF0ZS5pc0F1dGhlbnRpY2F0ZWQpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICByZXR1cm4gcGVybWlzc2lvbnMuc29tZShwZXJtaXNzaW9uID0+IGhhc1Blcm1pc3Npb24ocGVybWlzc2lvbikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHVzZXIgcGVybWlzc2lvbnMgKGRpcmVjdCArIHJvbGUtYmFzZWQpLlxuICAgKi9cbiAgY29uc3QgZ2V0VXNlclBlcm1pc3Npb25zID0gKCk6IFBlcm1pc3Npb25bXSA9PiB7XG4gICAgaWYgKCFzdGF0ZS51c2VyIHx8ICFzdGF0ZS5pc0F1dGhlbnRpY2F0ZWQpIHJldHVybiBbXTtcbiAgICBcbiAgICBjb25zdCBwZXJtaXNzaW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBQZXJtaXNzaW9uPigpO1xuICAgIFxuICAgIC8vIEFkZCBkaXJlY3QgcGVybWlzc2lvbnNcbiAgICBpZiAoc3RhdGUudXNlci5wZXJtaXNzaW9ucykge1xuICAgICAgc3RhdGUudXNlci5wZXJtaXNzaW9ucy5mb3JFYWNoKHAgPT4gcGVybWlzc2lvbnMuc2V0KHAuaWQsIHApKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHJvbGUgcGVybWlzc2lvbnNcbiAgICBpZiAoc3RhdGUudXNlci5yb2xlcykge1xuICAgICAgc3RhdGUudXNlci5yb2xlcy5mb3JFYWNoKHJvbGUgPT4ge1xuICAgICAgICByb2xlLnBlcm1pc3Npb25zLmZvckVhY2gocCA9PiBwZXJtaXNzaW9ucy5zZXQocC5pZCwgcCkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBBcnJheS5mcm9tKHBlcm1pc3Npb25zLnZhbHVlcygpKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFsbCB1c2VyIHJvbGVzLlxuICAgKi9cbiAgY29uc3QgZ2V0VXNlclJvbGVzID0gKCk6IFJvbGVbXSA9PiB7XG4gICAgaWYgKCFzdGF0ZS51c2VyIHx8ICFzdGF0ZS5pc0F1dGhlbnRpY2F0ZWQpIHJldHVybiBbXTtcbiAgICBcbiAgICByZXR1cm4gc3RhdGUudXNlci5yb2xlcyB8fCBbXTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdXNlciBpcyBhZG1pbiAoc3VwZXJ1c2VyIG9yIGhhcyBhZG1pbiByb2xlKS5cbiAgICovXG4gIGNvbnN0IGlzQWRtaW4gPSAoKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFzdGF0ZS51c2VyIHx8ICFzdGF0ZS5pc0F1dGhlbnRpY2F0ZWQpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICByZXR1cm4gc3RhdGUudXNlci5pc19zdXBlcnVzZXIgfHwgaGFzUm9sZSgnYWRtaW4nKSB8fCBoYXNSb2xlKCdvcmdhbml6YXRpb25fb3duZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdXNlciBjYW4gYWNjZXNzIGEgcmVzb3VyY2Ugd2l0aCBzcGVjaWZpYyBhY3Rpb24uXG4gICAqL1xuICBjb25zdCBjYW5BY2Nlc3MgPSAocmVzb3VyY2U6IHN0cmluZywgYWN0aW9uOiBzdHJpbmcsIG9yZ2FuaXphdGlvbklkPzogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFzdGF0ZS51c2VyIHx8ICFzdGF0ZS5pc0F1dGhlbnRpY2F0ZWQpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBCdWlsZCBwZXJtaXNzaW9uIG5hbWUgZnJvbSByZXNvdXJjZSBhbmQgYWN0aW9uXG4gICAgY29uc3QgcGVybWlzc2lvbk5hbWUgPSBgJHthY3Rpb259XyR7cmVzb3VyY2V9YDtcbiAgICBcbiAgICByZXR1cm4gaGFzUGVybWlzc2lvbihwZXJtaXNzaW9uTmFtZSwgb3JnYW5pemF0aW9uSWQpO1xuICB9O1xuXG4gIGNvbnN0IGNvbnRleHRWYWx1ZTogQXV0aENvbnRleHRUeXBlID0ge1xuICAgIHN0YXRlLFxuICAgIGxvZ2luLFxuICAgIGxvZ291dCxcbiAgICByZWZyZXNoVG9rZW4sXG4gICAgZ2V0Q3VycmVudFVzZXIsXG4gICAgaGFzUGVybWlzc2lvbixcbiAgICBoYXNSb2xlLFxuICAgIGhhc0FueVJvbGUsXG4gICAgaGFzQW55UGVybWlzc2lvbixcbiAgICBnZXRVc2VyUGVybWlzc2lvbnMsXG4gICAgZ2V0VXNlclJvbGVzLFxuICAgIGlzQWRtaW4sXG4gICAgY2FuQWNjZXNzLFxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEF1dGhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0VmFsdWV9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXV0aENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG4vKipcbiAqIEhvb2sgdG8gYWNjZXNzIGF1dGhlbnRpY2F0aW9uIGNvbnRleHQuXG4gKiBcbiAqIEByZXR1cm5zIEF1dGhDb250ZXh0VHlwZSAtIEF1dGhlbnRpY2F0aW9uIHN0YXRlIGFuZCBtZXRob2RzXG4gKiBAdGhyb3dzIEVycm9yIGlmIHVzZWQgb3V0c2lkZSBBdXRoUHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHVzZUF1dGggPSAoKTogQXV0aENvbnRleHRUeXBlID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQXV0aENvbnRleHQpO1xuICBcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlcicpO1xuICB9XG4gIFxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGhDb250ZXh0OyAiXSwibmFtZXMiOlsiQXV0aFByb3ZpZGVyIiwidXNlQXV0aCIsImluaXRpYWxTdGF0ZSIsImlzQXV0aGVudGljYXRlZCIsImlzTG9hZGluZyIsInVzZXIiLCJ0b2tlbnMiLCJlcnJvciIsImF1dGhSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJ0eXBlIiwicGF5bG9hZCIsIkF1dGhDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVuZGVmaW5lZCIsIlNUT1JBR0VfS0VZUyIsIkFDQ0VTU19UT0tFTiIsIlJFRlJFU0hfVE9LRU4iLCJVU0VSX0RBVEEiLCJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMIiwiY2hpbGRyZW4iLCJkaXNwYXRjaCIsInVzZVJlZHVjZXIiLCJ1c2VFZmZlY3QiLCJpbml0aWFsaXplQXV0aCIsImFjY2Vzc1Rva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInJlZnJlc2hUb2tlbiIsInVzZXJEYXRhIiwiSlNPTiIsInBhcnNlIiwiYWNjZXNzX3Rva2VuIiwicmVmcmVzaF90b2tlbiIsInRva2VuX3R5cGUiLCJnZXRDdXJyZW50VXNlciIsImNsZWFyU3RvcmVkQXV0aCIsInJlbW92ZUl0ZW0iLCJzdG9yZUF1dGhEYXRhIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImF1dGhlbnRpY2F0ZWRGZXRjaCIsInVybCIsIm9wdGlvbnMiLCJFcnJvciIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwic3RhdHVzIiwicmVmcmVzaEVycm9yIiwibG9nb3V0IiwibG9naW4iLCJjb2RlIiwic3RhdGVfcGFyYW0iLCJtZXRob2QiLCJib2R5Iiwib2siLCJqc29uIiwiZGV0YWlsIiwidXNlclJlc3BvbnNlIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiaGFzUGVybWlzc2lvbiIsInBlcm1pc3Npb24iLCJvcmdhbml6YXRpb25JZCIsImlzX3N1cGVydXNlciIsInBlcm1pc3Npb25zIiwic29tZSIsInAiLCJuYW1lIiwib3JnYW5pemF0aW9uX2lkIiwicm9sZXMiLCJyb2xlIiwiaGFzUm9sZSIsInIiLCJoYXNBbnlSb2xlIiwiaGFzQW55UGVybWlzc2lvbiIsImdldFVzZXJQZXJtaXNzaW9ucyIsIk1hcCIsImZvckVhY2giLCJzZXQiLCJpZCIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImdldFVzZXJSb2xlcyIsImlzQWRtaW4iLCJjYW5BY2Nlc3MiLCJyZXNvdXJjZSIsInBlcm1pc3Npb25OYW1lIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImNvbnRleHQiLCJ1c2VDb250ZXh0Il0sIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0MsR0FDRDs7Ozs7Ozs7Ozs7O0lBbUxhQSxZQUFZO2VBQVpBOztJQTJZYixPQUEyQjtlQUEzQjs7SUFWYUMsT0FBTztlQUFQQTs7OzsrREFsakJzRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0duRixnQkFBZ0I7QUFDaEIsTUFBTUMsZUFBMEI7SUFDOUJDLGlCQUFpQjtJQUNqQkMsV0FBVztJQUNYQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsT0FBTztBQUNUO0FBRUEsZUFBZTtBQUNmLFNBQVNDLFlBQVlDLEtBQWdCLEVBQUVDLE1BQWtCO0lBQ3ZELE9BQVFBLE9BQU9DLElBQUk7UUFDakIsS0FBSztZQUNILE9BQU87Z0JBQ0wsR0FBR0YsS0FBSztnQkFDUkwsV0FBVztnQkFDWEcsT0FBTztZQUNUO1FBQ0YsS0FBSztZQUNILE9BQU87Z0JBQ0wsR0FBR0UsS0FBSztnQkFDUk4saUJBQWlCO2dCQUNqQkMsV0FBVztnQkFDWEMsTUFBTUssT0FBT0UsT0FBTyxDQUFDUCxJQUFJO2dCQUN6QkMsUUFBUUksT0FBT0UsT0FBTyxDQUFDTixNQUFNO2dCQUM3QkMsT0FBTztZQUNUO1FBQ0YsS0FBSztZQUNILE9BQU87Z0JBQ0wsR0FBR0UsS0FBSztnQkFDUk4saUJBQWlCO2dCQUNqQkMsV0FBVztnQkFDWEMsTUFBTTtnQkFDTkMsUUFBUTtnQkFDUkMsT0FBT0csT0FBT0UsT0FBTztZQUN2QjtRQUNGLEtBQUs7WUFDSCxPQUFPO2dCQUNMLEdBQUdWLFlBQVk7WUFDakI7UUFDRixLQUFLO1lBQ0gsT0FBTztnQkFDTCxHQUFHTyxLQUFLO2dCQUNSSCxRQUFRSSxPQUFPRSxPQUFPO2dCQUN0QkwsT0FBTztZQUNUO1FBQ0YsS0FBSztZQUNILE9BQU87Z0JBQ0wsR0FBR0UsS0FBSztnQkFDUkosTUFBTUssT0FBT0UsT0FBTztZQUN0QjtRQUNGO1lBQ0UsT0FBT0g7SUFDWDtBQUNGO0FBRUEsaUJBQWlCO0FBQ2pCLE1BQU1JLDRCQUFjQyxJQUFBQSxvQkFBYSxFQUE4QkM7QUFFL0QsZUFBZTtBQUNmLE1BQU1DLGVBQWU7SUFDbkJDLGNBQWM7SUFDZEMsZUFBZTtJQUNmQyxXQUFXO0FBQ2I7QUFFQSx3REFBd0Q7QUFDeEQsTUFBTUMsZUFBZUMsUUFBUUMsR0FBRyxDQUFDQyx3QkFBd0IsSUFBSTtBQVV0RCxNQUFNdkIsZUFBa0QsQ0FBQyxFQUFFd0IsUUFBUSxFQUFFO0lBQzFFLE1BQU0sQ0FBQ2YsT0FBT2dCLFNBQVMsR0FBR0MsSUFBQUEsaUJBQVUsRUFBQ2xCLGFBQWFOO0lBRWxEOztHQUVDLEdBQ0R5QixJQUFBQSxnQkFBUyxFQUFDO1FBQ1IsTUFBTUMsaUJBQWlCO1lBQ3JCLE1BQU1DLGNBQWNDLGFBQWFDLE9BQU8sQ0FBQ2YsYUFBYUMsWUFBWTtZQUNsRSxNQUFNZSxlQUFlRixhQUFhQyxPQUFPLENBQUNmLGFBQWFFLGFBQWE7WUFDcEUsTUFBTWUsV0FBV0gsYUFBYUMsT0FBTyxDQUFDZixhQUFhRyxTQUFTO1lBRTVELElBQUlVLGVBQWVJLFVBQVU7Z0JBQzNCLElBQUk7b0JBQ0YsTUFBTTVCLE9BQU82QixLQUFLQyxLQUFLLENBQUNGO29CQUN4QixNQUFNM0IsU0FBUzt3QkFDYjhCLGNBQWNQO3dCQUNkUSxlQUFlTCxnQkFBZ0JqQjt3QkFDL0J1QixZQUFZO29CQUNkO29CQUVBYixTQUFTO3dCQUNQZCxNQUFNO3dCQUNOQyxTQUFTOzRCQUFFUDs0QkFBTUM7d0JBQU87b0JBQzFCO29CQUVBLHVEQUF1RDtvQkFDdkQsTUFBTWlDO2dCQUNSLEVBQUUsT0FBT2hDLE9BQU87b0JBQ2Qsb0NBQW9DO29CQUNwQ2lDO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBWjtJQUNGLEdBQUcsRUFBRTtJQUVMOztHQUVDLEdBQ0QsTUFBTVksa0JBQWtCO1FBQ3RCVixhQUFhVyxVQUFVLENBQUN6QixhQUFhQyxZQUFZO1FBQ2pEYSxhQUFhVyxVQUFVLENBQUN6QixhQUFhRSxhQUFhO1FBQ2xEWSxhQUFhVyxVQUFVLENBQUN6QixhQUFhRyxTQUFTO0lBQ2hEO0lBRUE7O0dBRUMsR0FDRCxNQUFNdUIsZ0JBQWdCLENBQUNyQyxNQUFZQztRQUNqQ3dCLGFBQWFhLE9BQU8sQ0FBQzNCLGFBQWFDLFlBQVksRUFBRVgsT0FBTzhCLFlBQVk7UUFDbkUsSUFBSTlCLE9BQU8rQixhQUFhLEVBQUU7WUFDeEJQLGFBQWFhLE9BQU8sQ0FBQzNCLGFBQWFFLGFBQWEsRUFBRVosT0FBTytCLGFBQWE7UUFDdkU7UUFDQVAsYUFBYWEsT0FBTyxDQUFDM0IsYUFBYUcsU0FBUyxFQUFFZSxLQUFLVSxTQUFTLENBQUN2QztJQUM5RDtJQUVBOztHQUVDLEdBQ0QsTUFBTXdDLHFCQUFxQixPQUN6QkMsS0FDQUMsVUFBdUIsQ0FBQyxDQUFDO1FBRXpCLE1BQU1sQixjQUFjcEIsTUFBTUgsTUFBTSxFQUFFOEI7UUFFbEMsSUFBSSxDQUFDUCxhQUFhO1lBQ2hCLE1BQU0sSUFBSW1CLE1BQU07UUFDbEI7UUFFQSxNQUFNQyxXQUFXLE1BQU1DLE1BQU1KLEtBQUs7WUFDaEMsR0FBR0MsT0FBTztZQUNWSSxTQUFTO2dCQUNQLEdBQUdKLFFBQVFJLE9BQU87Z0JBQ2xCLGlCQUFpQixDQUFDLE9BQU8sRUFBRXRCLGFBQWE7Z0JBQ3hDLGdCQUFnQjtZQUNsQjtRQUNGO1FBRUEsbUNBQW1DO1FBQ25DLElBQUlvQixTQUFTRyxNQUFNLEtBQUssT0FBTzNDLE1BQU1ILE1BQU0sRUFBRStCLGVBQWU7WUFDMUQsSUFBSTtnQkFDRixNQUFNTDtnQkFDTixtQ0FBbUM7Z0JBQ25DLE9BQU9rQixNQUFNSixLQUFLO29CQUNoQixHQUFHQyxPQUFPO29CQUNWSSxTQUFTO3dCQUNQLEdBQUdKLFFBQVFJLE9BQU87d0JBQ2xCLGlCQUFpQixDQUFDLE9BQU8sRUFBRTFDLE1BQU1ILE1BQU0sRUFBRThCLGNBQWM7d0JBQ3ZELGdCQUFnQjtvQkFDbEI7Z0JBQ0Y7WUFDRixFQUFFLE9BQU9pQixjQUFjO2dCQUNyQiw4QkFBOEI7Z0JBQzlCLE1BQU1DO2dCQUNOLE1BQU0sSUFBSU4sTUFBTTtZQUNsQjtRQUNGO1FBRUEsT0FBT0M7SUFDVDtJQUVBOztHQUVDLEdBQ0QsTUFBTU0sUUFBUSxPQUFPQyxNQUFjQztRQUNqQ2hDLFNBQVM7WUFBRWQsTUFBTTtRQUFhO1FBRTlCLElBQUk7WUFDRixNQUFNc0MsV0FBVyxNQUFNQyxNQUFNLEdBQUc5QixhQUFhLGtCQUFrQixDQUFDLEVBQUU7Z0JBQ2hFc0MsUUFBUTtnQkFDUlAsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBUSxNQUFNekIsS0FBS1UsU0FBUyxDQUFDO29CQUNuQlk7b0JBQ0EvQyxPQUFPZ0Q7Z0JBQ1Q7WUFDRjtZQUVBLElBQUksQ0FBQ1IsU0FBU1csRUFBRSxFQUFFO2dCQUNoQixNQUFNckQsUUFBUSxNQUFNMEMsU0FBU1ksSUFBSTtnQkFDakMsTUFBTSxJQUFJYixNQUFNekMsTUFBTXVELE1BQU0sSUFBSTtZQUNsQztZQUVBLE1BQU14RCxTQUFxQixNQUFNMkMsU0FBU1ksSUFBSTtZQUU5QyxnQkFBZ0I7WUFDaEIsTUFBTUUsZUFBZSxNQUFNYixNQUFNLEdBQUc5QixhQUFhLFFBQVEsQ0FBQyxFQUFFO2dCQUMxRCtCLFNBQVM7b0JBQ1AsaUJBQWlCLENBQUMsT0FBTyxFQUFFN0MsT0FBTzhCLFlBQVksRUFBRTtnQkFDbEQ7WUFDRjtZQUVBLElBQUksQ0FBQzJCLGFBQWFILEVBQUUsRUFBRTtnQkFDcEIsTUFBTSxJQUFJWixNQUFNO1lBQ2xCO1lBRUEsTUFBTTNDLE9BQWEsTUFBTTBELGFBQWFGLElBQUk7WUFFMUMsa0JBQWtCO1lBQ2xCbkIsY0FBY3JDLE1BQU1DO1lBRXBCbUIsU0FBUztnQkFDUGQsTUFBTTtnQkFDTkMsU0FBUztvQkFBRVA7b0JBQU1DO2dCQUFPO1lBQzFCO1FBQ0YsRUFBRSxPQUFPQyxPQUFPO1lBQ2QsTUFBTXlELFVBQVV6RCxpQkFBaUJ5QyxRQUFRekMsTUFBTXlELE9BQU8sR0FBRztZQUN6RHZDLFNBQVM7Z0JBQUVkLE1BQU07Z0JBQWdCQyxTQUFTb0Q7WUFBUTtZQUNsRCxNQUFNekQ7UUFDUjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFNK0MsU0FBUztRQUNiLElBQUk7WUFDRix3Q0FBd0M7WUFDeEMsSUFBSTdDLE1BQU1ILE1BQU0sRUFBRThCLGNBQWM7Z0JBQzlCLE1BQU1TLG1CQUFtQixHQUFHekIsYUFBYSxZQUFZLENBQUMsRUFBRTtvQkFDdERzQyxRQUFRO2dCQUNWO1lBQ0Y7UUFDRixFQUFFLE9BQU9uRCxPQUFPO1lBQ2QscUNBQXFDO1lBQ3JDMEQsUUFBUUMsSUFBSSxDQUFDLDJCQUEyQjNEO1FBQzFDLFNBQVU7WUFDUix1Q0FBdUM7WUFDdkNpQztZQUNBZixTQUFTO2dCQUFFZCxNQUFNO1lBQWM7UUFDakM7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTXFCLGVBQWU7UUFDbkIsTUFBTUssZ0JBQWdCNUIsTUFBTUgsTUFBTSxFQUFFK0I7UUFFcEMsSUFBSSxDQUFDQSxlQUFlO1lBQ2xCLE1BQU0sSUFBSVcsTUFBTTtRQUNsQjtRQUVBLElBQUk7WUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU0sR0FBRzlCLGFBQWEsYUFBYSxDQUFDLEVBQUU7Z0JBQzNEc0MsUUFBUTtnQkFDUlAsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBUSxNQUFNekIsS0FBS1UsU0FBUyxDQUFDO29CQUNuQlA7Z0JBQ0Y7WUFDRjtZQUVBLElBQUksQ0FBQ1ksU0FBU1csRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUlaLE1BQU07WUFDbEI7WUFFQSxNQUFNMUMsU0FBcUIsTUFBTTJDLFNBQVNZLElBQUk7WUFFOUMsdUJBQXVCO1lBQ3ZCL0IsYUFBYWEsT0FBTyxDQUFDM0IsYUFBYUMsWUFBWSxFQUFFWCxPQUFPOEIsWUFBWTtZQUNuRSxJQUFJOUIsT0FBTytCLGFBQWEsRUFBRTtnQkFDeEJQLGFBQWFhLE9BQU8sQ0FBQzNCLGFBQWFFLGFBQWEsRUFBRVosT0FBTytCLGFBQWE7WUFDdkU7WUFFQVosU0FBUztnQkFDUGQsTUFBTTtnQkFDTkMsU0FBU047WUFDWDtRQUNGLEVBQUUsT0FBT0MsT0FBTztZQUNkLDhCQUE4QjtZQUM5QixNQUFNK0M7WUFDTixNQUFNL0M7UUFDUjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFNZ0MsaUJBQWlCO1FBQ3JCLElBQUk7WUFDRixNQUFNVSxXQUFXLE1BQU1KLG1CQUFtQixHQUFHekIsYUFBYSxRQUFRLENBQUM7WUFFbkUsSUFBSSxDQUFDNkIsU0FBU1csRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUlaLE1BQU07WUFDbEI7WUFFQSxNQUFNM0MsT0FBYSxNQUFNNEMsU0FBU1ksSUFBSTtZQUV0QywwQkFBMEI7WUFDMUIvQixhQUFhYSxPQUFPLENBQUMzQixhQUFhRyxTQUFTLEVBQUVlLEtBQUtVLFNBQVMsQ0FBQ3ZDO1lBRTVEb0IsU0FBUztnQkFDUGQsTUFBTTtnQkFDTkMsU0FBU1A7WUFDWDtRQUNGLEVBQUUsT0FBT0UsT0FBTztZQUNkMEQsUUFBUTFELEtBQUssQ0FBQywrQkFBK0JBO1lBQzdDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTTRELGdCQUFnQixDQUFDQyxZQUFvQkM7UUFDekMsSUFBSSxDQUFDNUQsTUFBTUosSUFBSSxJQUFJLENBQUNJLE1BQU1OLGVBQWUsRUFBRSxPQUFPO1FBRWxELGdDQUFnQztRQUNoQyxJQUFJTSxNQUFNSixJQUFJLENBQUNpRSxZQUFZLEVBQUUsT0FBTztRQUVwQyx5QkFBeUI7UUFDekIsSUFBSTdELE1BQU1KLElBQUksQ0FBQ2tFLFdBQVcsRUFBRTtZQUMxQixPQUFPOUQsTUFBTUosSUFBSSxDQUFDa0UsV0FBVyxDQUFDQyxJQUFJLENBQUNDLENBQUFBLElBQ2pDQSxFQUFFQyxJQUFJLEtBQUtOLGNBQ1YsQ0FBQSxDQUFDQyxrQkFBa0IsQ0FBQ0ksRUFBRUUsZUFBZSxJQUFJRixFQUFFRSxlQUFlLEtBQUtOLGNBQWE7UUFFakY7UUFFQSx5QkFBeUI7UUFDekIsSUFBSTVELE1BQU1KLElBQUksQ0FBQ3VFLEtBQUssRUFBRTtZQUNwQixPQUFPbkUsTUFBTUosSUFBSSxDQUFDdUUsS0FBSyxDQUFDSixJQUFJLENBQUNLLENBQUFBLE9BQzNCQSxLQUFLTixXQUFXLENBQUNDLElBQUksQ0FBQ0MsQ0FBQUEsSUFDcEJBLEVBQUVDLElBQUksS0FBS04sY0FDVixDQUFBLENBQUNDLGtCQUFrQixDQUFDSSxFQUFFRSxlQUFlLElBQUlGLEVBQUVFLGVBQWUsS0FBS04sY0FBYTtRQUduRjtRQUVBLE9BQU87SUFDVDtJQUVBOztHQUVDLEdBQ0QsTUFBTVMsVUFBVSxDQUFDRDtRQUNmLElBQUksQ0FBQ3BFLE1BQU1KLElBQUksSUFBSSxDQUFDSSxNQUFNTixlQUFlLEVBQUUsT0FBTztRQUVsRCxPQUFPTSxNQUFNSixJQUFJLENBQUN1RSxLQUFLLEVBQUVKLEtBQUtPLENBQUFBLElBQUtBLEVBQUVMLElBQUksS0FBS0csU0FBUztJQUN6RDtJQUVBOztHQUVDLEdBQ0QsTUFBTUcsYUFBYSxDQUFDSjtRQUNsQixJQUFJLENBQUNuRSxNQUFNSixJQUFJLElBQUksQ0FBQ0ksTUFBTU4sZUFBZSxFQUFFLE9BQU87UUFFbEQsT0FBT3lFLE1BQU1KLElBQUksQ0FBQ0ssQ0FBQUEsT0FBUUMsUUFBUUQ7SUFDcEM7SUFFQTs7R0FFQyxHQUNELE1BQU1JLG1CQUFtQixDQUFDVjtRQUN4QixJQUFJLENBQUM5RCxNQUFNSixJQUFJLElBQUksQ0FBQ0ksTUFBTU4sZUFBZSxFQUFFLE9BQU87UUFFbEQsT0FBT29FLFlBQVlDLElBQUksQ0FBQ0osQ0FBQUEsYUFBY0QsY0FBY0M7SUFDdEQ7SUFFQTs7R0FFQyxHQUNELE1BQU1jLHFCQUFxQjtRQUN6QixJQUFJLENBQUN6RSxNQUFNSixJQUFJLElBQUksQ0FBQ0ksTUFBTU4sZUFBZSxFQUFFLE9BQU8sRUFBRTtRQUVwRCxNQUFNb0UsY0FBYyxJQUFJWTtRQUV4Qix5QkFBeUI7UUFDekIsSUFBSTFFLE1BQU1KLElBQUksQ0FBQ2tFLFdBQVcsRUFBRTtZQUMxQjlELE1BQU1KLElBQUksQ0FBQ2tFLFdBQVcsQ0FBQ2EsT0FBTyxDQUFDWCxDQUFBQSxJQUFLRixZQUFZYyxHQUFHLENBQUNaLEVBQUVhLEVBQUUsRUFBRWI7UUFDNUQ7UUFFQSx1QkFBdUI7UUFDdkIsSUFBSWhFLE1BQU1KLElBQUksQ0FBQ3VFLEtBQUssRUFBRTtZQUNwQm5FLE1BQU1KLElBQUksQ0FBQ3VFLEtBQUssQ0FBQ1EsT0FBTyxDQUFDUCxDQUFBQTtnQkFDdkJBLEtBQUtOLFdBQVcsQ0FBQ2EsT0FBTyxDQUFDWCxDQUFBQSxJQUFLRixZQUFZYyxHQUFHLENBQUNaLEVBQUVhLEVBQUUsRUFBRWI7WUFDdEQ7UUFDRjtRQUVBLE9BQU9jLE1BQU1DLElBQUksQ0FBQ2pCLFlBQVlrQixNQUFNO0lBQ3RDO0lBRUE7O0dBRUMsR0FDRCxNQUFNQyxlQUFlO1FBQ25CLElBQUksQ0FBQ2pGLE1BQU1KLElBQUksSUFBSSxDQUFDSSxNQUFNTixlQUFlLEVBQUUsT0FBTyxFQUFFO1FBRXBELE9BQU9NLE1BQU1KLElBQUksQ0FBQ3VFLEtBQUssSUFBSSxFQUFFO0lBQy9CO0lBRUE7O0dBRUMsR0FDRCxNQUFNZSxVQUFVO1FBQ2QsSUFBSSxDQUFDbEYsTUFBTUosSUFBSSxJQUFJLENBQUNJLE1BQU1OLGVBQWUsRUFBRSxPQUFPO1FBRWxELE9BQU9NLE1BQU1KLElBQUksQ0FBQ2lFLFlBQVksSUFBSVEsUUFBUSxZQUFZQSxRQUFRO0lBQ2hFO0lBRUE7O0dBRUMsR0FDRCxNQUFNYyxZQUFZLENBQUNDLFVBQWtCbkYsUUFBZ0IyRDtRQUNuRCxJQUFJLENBQUM1RCxNQUFNSixJQUFJLElBQUksQ0FBQ0ksTUFBTU4sZUFBZSxFQUFFLE9BQU87UUFFbEQsaURBQWlEO1FBQ2pELE1BQU0yRixpQkFBaUIsR0FBR3BGLE9BQU8sQ0FBQyxFQUFFbUYsVUFBVTtRQUU5QyxPQUFPMUIsY0FBYzJCLGdCQUFnQnpCO0lBQ3ZDO0lBRUEsTUFBTTBCLGVBQWdDO1FBQ3BDdEY7UUFDQThDO1FBQ0FEO1FBQ0F0QjtRQUNBTztRQUNBNEI7UUFDQVc7UUFDQUU7UUFDQUM7UUFDQUM7UUFDQVE7UUFDQUM7UUFDQUM7SUFDRjtJQUVBLHFCQUNFLHFCQUFDL0UsWUFBWW1GLFFBQVE7UUFBQ0MsT0FBT0Y7a0JBQzFCdkU7O0FBR1A7QUFRTyxNQUFNdkIsVUFBVTtJQUNyQixNQUFNaUcsVUFBVUMsSUFBQUEsaUJBQVUsRUFBQ3RGO0lBRTNCLElBQUlxRixZQUFZbkYsV0FBVztRQUN6QixNQUFNLElBQUlpQyxNQUFNO0lBQ2xCO0lBRUEsT0FBT2tEO0FBQ1Q7TUFFQSxXQUFlckYifQ==