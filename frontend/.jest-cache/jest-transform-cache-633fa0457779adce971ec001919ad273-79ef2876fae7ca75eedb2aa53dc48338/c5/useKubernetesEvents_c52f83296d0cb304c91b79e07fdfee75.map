{"version":3,"sources":["/Users/pavan/Desktop/Devops-app-dev-cursor/frontend/src/hooks/useKubernetesEvents.ts"],"sourcesContent":["/**\n * React Hook for Kubernetes Real-time Events\n * \n * Provides easy integration with the WebSocket service for receiving\n * real-time Kubernetes events in React components.\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { \n  KubernetesEvent, \n  EventSubscription, \n  getWebSocketService \n} from '../services/websocket';\n\nexport interface UseKubernetesEventsOptions {\n  /** Event types to subscribe to */\n  eventTypes?: string[];\n  /** Specific cluster ID to filter events */\n  clusterId?: string;\n  /** Enable/disable real-time updates */\n  enabled?: boolean;\n  /** Auto-connect to WebSocket on mount */\n  autoConnect?: boolean;\n  /** Maximum number of events to keep in memory */\n  maxEvents?: number;\n  /** Event filter function */\n  eventFilter?: (event: KubernetesEvent) => boolean;\n}\n\nexport interface KubernetesEventsState {\n  /** Array of received events */\n  events: KubernetesEvent[];\n  /** Current connection status */\n  isConnected: boolean;\n  /** Connection error if any */\n  error: string | null;\n  /** Loading state during connection */\n  isConnecting: boolean;\n  /** Number of active subscriptions */\n  subscriptionCount: number;\n}\n\nexport interface KubernetesEventsActions {\n  /** Manually connect to WebSocket */\n  connect: () => Promise<void>;\n  /** Disconnect from WebSocket */\n  disconnect: () => void;\n  /** Clear all stored events */\n  clearEvents: () => void;\n  /** Add a new event subscription */\n  addSubscription: (types: string[], callback?: (event: KubernetesEvent) => void) => string;\n  /** Remove an event subscription */\n  removeSubscription: (subscriptionId: string) => void;\n  /** Get events by type */\n  getEventsByType: (type: string) => KubernetesEvent[];\n  /** Get events by severity */\n  getEventsBySeverity: (severity: string) => KubernetesEvent[];\n}\n\n/**\n * Hook for managing Kubernetes real-time events\n */\nexport function useKubernetesEvents(\n  options: UseKubernetesEventsOptions = {}\n): [KubernetesEventsState, KubernetesEventsActions] {\n  const {\n    eventTypes = ['all'],\n    clusterId,\n    enabled = true,\n    autoConnect = true,\n    maxEvents = 1000,\n    eventFilter\n  } = options;\n\n  // State\n  const [events, setEvents] = useState<KubernetesEvent[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [subscriptionCount, setSubscriptionCount] = useState(0);\n\n  // Refs\n  const wsService = useRef(getWebSocketService());\n  const subscriptionIds = useRef<Set<string>>(new Set());\n  const connectionCheck = useRef<NodeJS.Timeout | null>(null);\n\n  /**\n   * Handle incoming events\n   */\n  const handleEvent = useCallback((event: KubernetesEvent) => {\n    // Apply event filter if provided\n    if (eventFilter && !eventFilter(event)) {\n      return;\n    }\n\n    setEvents(prevEvents => {\n      const newEvents = [event, ...prevEvents];\n      // Limit the number of events to prevent memory issues\n      return newEvents.slice(0, maxEvents);\n    });\n  }, [eventFilter, maxEvents]);\n\n  /**\n   * Connect to WebSocket\n   */\n  const connect = useCallback(async () => {\n    if (!enabled) return;\n\n    try {\n      setIsConnecting(true);\n      setError(null);\n      \n      await wsService.current.connect();\n      setIsConnected(true);\n      \n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Connection failed');\n      setIsConnected(false);\n    } finally {\n      setIsConnecting(false);\n    }\n  }, [enabled]);\n\n  /**\n   * Disconnect from WebSocket\n   */\n  const disconnect = useCallback(() => {\n    wsService.current.disconnect();\n    setIsConnected(false);\n    setError(null);\n    setIsConnecting(false);\n  }, []);\n\n  /**\n   * Clear all stored events\n   */\n  const clearEvents = useCallback(() => {\n    setEvents([]);\n  }, []);\n\n  /**\n   * Add a new event subscription\n   */\n  const addSubscription = useCallback((\n    types: string[], \n    callback?: (event: KubernetesEvent) => void\n  ): string => {\n    const subscriptionId = wsService.current.subscribe({\n      types,\n      clusterId,\n      callback: (event) => {\n        handleEvent(event);\n        callback?.(event);\n      }\n    });\n\n    subscriptionIds.current.add(subscriptionId);\n    setSubscriptionCount(subscriptionIds.current.size);\n    \n    return subscriptionId;\n  }, [clusterId, handleEvent]);\n\n  /**\n   * Remove an event subscription\n   */\n  const removeSubscription = useCallback((subscriptionId: string) => {\n    wsService.current.unsubscribe(subscriptionId);\n    subscriptionIds.current.delete(subscriptionId);\n    setSubscriptionCount(subscriptionIds.current.size);\n  }, []);\n\n  /**\n   * Get events by type\n   */\n  const getEventsByType = useCallback((type: string): KubernetesEvent[] => {\n    return events.filter(event => event.type === type);\n  }, [events]);\n\n  /**\n   * Get events by severity\n   */\n  const getEventsBySeverity = useCallback((severity: string): KubernetesEvent[] => {\n    return events.filter(event => event.severity === severity);\n  }, [events]);\n\n  /**\n   * Monitor connection status\n   */\n  const checkConnectionStatus = useCallback(() => {\n    const connected = wsService.current.isConnectedStatus();\n    if (connected !== isConnected) {\n      setIsConnected(connected);\n    }\n  }, [isConnected]);\n\n  /**\n   * Setup initial subscription\n   */\n  useEffect(() => {\n    if (enabled && eventTypes.length > 0) {\n      const subscriptionId = addSubscription(eventTypes);\n      \n      return () => {\n        removeSubscription(subscriptionId);\n      };\n    }\n  }, [enabled, eventTypes, addSubscription, removeSubscription]);\n\n  /**\n   * Auto-connect on mount if enabled\n   */\n  useEffect(() => {\n    if (autoConnect && enabled) {\n      connect();\n    }\n\n    return () => {\n      // Cleanup subscriptions on unmount\n      subscriptionIds.current.forEach(id => {\n        wsService.current.unsubscribe(id);\n      });\n      subscriptionIds.current.clear();\n    };\n  }, [autoConnect, enabled, connect]);\n\n  /**\n   * Connection status monitoring\n   */\n  useEffect(() => {\n    connectionCheck.current = setInterval(checkConnectionStatus, 5000);\n    \n    return () => {\n      if (connectionCheck.current) {\n        clearInterval(connectionCheck.current);\n      }\n    };\n  }, [checkConnectionStatus]);\n\n  /**\n   * Cleanup on unmount\n   */\n  useEffect(() => {\n    return () => {\n      if (connectionCheck.current) {\n        clearInterval(connectionCheck.current);\n      }\n    };\n  }, []);\n\n  // Return state and actions\n  const state: KubernetesEventsState = {\n    events,\n    isConnected,\n    error,\n    isConnecting,\n    subscriptionCount\n  };\n\n  const actions: KubernetesEventsActions = {\n    connect,\n    disconnect,\n    clearEvents,\n    addSubscription,\n    removeSubscription,\n    getEventsByType,\n    getEventsBySeverity\n  };\n\n  return [state, actions];\n}\n\n/**\n * Hook for specific event types\n */\nexport function usePodEvents(clusterId?: string) {\n  return useKubernetesEvents({\n    eventTypes: ['pod'],\n    clusterId,\n    autoConnect: true\n  });\n}\n\nexport function useNodeEvents(clusterId?: string) {\n  return useKubernetesEvents({\n    eventTypes: ['node'],\n    clusterId,\n    autoConnect: true\n  });\n}\n\nexport function useClusterEvents(clusterId?: string) {\n  return useKubernetesEvents({\n    eventTypes: ['cluster'],\n    clusterId,\n    autoConnect: true\n  });\n}\n\nexport function useAlertEvents(clusterId?: string) {\n  return useKubernetesEvents({\n    eventTypes: ['alert'],\n    clusterId,\n    autoConnect: true,\n    eventFilter: (event) => event.severity === 'critical' || event.severity === 'error'\n  });\n}\n\n/**\n * Hook for connection status only\n */\nexport function useWebSocketConnection() {\n  const [state] = useKubernetesEvents({\n    enabled: true,\n    autoConnect: true,\n    eventTypes: []\n  });\n\n  return {\n    isConnected: state.isConnected,\n    isConnecting: state.isConnecting,\n    error: state.error\n  };\n} "],"names":["useAlertEvents","useClusterEvents","useKubernetesEvents","useNodeEvents","usePodEvents","useWebSocketConnection","options","eventTypes","clusterId","enabled","autoConnect","maxEvents","eventFilter","events","setEvents","useState","isConnected","setIsConnected","error","setError","isConnecting","setIsConnecting","subscriptionCount","setSubscriptionCount","wsService","useRef","getWebSocketService","subscriptionIds","Set","connectionCheck","handleEvent","useCallback","event","prevEvents","newEvents","slice","connect","current","err","Error","message","disconnect","clearEvents","addSubscription","types","callback","subscriptionId","subscribe","add","size","removeSubscription","unsubscribe","delete","getEventsByType","type","filter","getEventsBySeverity","severity","checkConnectionStatus","connected","isConnectedStatus","useEffect","length","forEach","id","clear","setInterval","clearInterval","state","actions"],"mappings":"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"}