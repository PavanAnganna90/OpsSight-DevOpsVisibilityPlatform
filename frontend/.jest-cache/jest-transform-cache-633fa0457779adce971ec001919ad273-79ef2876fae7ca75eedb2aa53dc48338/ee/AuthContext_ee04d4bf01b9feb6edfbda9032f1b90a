7a0bc0341e009e750b443ca9f83ead6c
/**
 * Enhanced Authentication context for managing user session state.
 * Provides authentication state, user data, auth methods, and backend integration.
 * Optimized for enterprise-grade authentication flow.
 */ 'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AuthProvider: function() {
        return AuthProvider;
    },
    default: function() {
        return _default;
    },
    useAuth: function() {
        return useAuth;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _apiService = require("../services/apiService");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Initial state
const initialState = {
    isAuthenticated: false,
    isLoading: false,
    user: null,
    tokens: null,
    error: null
};
// Auth reducer
function authReducer(state, action) {
    switch(action.type){
        case 'AUTH_START':
            return {
                ...state,
                isLoading: true,
                error: null
            };
        case 'AUTH_SUCCESS':
            return {
                ...state,
                isAuthenticated: true,
                isLoading: false,
                user: action.payload.user,
                tokens: action.payload.tokens,
                error: null
            };
        case 'AUTH_FAILURE':
            return {
                ...state,
                isAuthenticated: false,
                isLoading: false,
                user: null,
                tokens: null,
                error: action.payload
            };
        case 'AUTH_LOGOUT':
            return {
                ...initialState
            };
        case 'AUTH_REFRESH_SUCCESS':
            return {
                ...state,
                tokens: action.payload,
                error: null
            };
        case 'AUTH_UPDATE_USER':
            return {
                ...state,
                user: action.payload
            };
        default:
            return state;
    }
}
// Create context
const AuthContext = /*#__PURE__*/ (0, _react.createContext)(undefined);
// Storage keys
const STORAGE_KEYS = {
    ACCESS_TOKEN: 'opsight_access_token',
    REFRESH_TOKEN: 'opsight_refresh_token',
    USER_DATA: 'opsight_user_data'
};
// API base URL - Use process.env for Jest compatibility
const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:8000/api/v1';
const AuthProvider = ({ children })=>{
    const [state, dispatch] = (0, _react.useReducer)(authReducer, initialState);
    /**
   * Initialize authentication state from stored tokens on app start.
   */ (0, _react.useEffect)(()=>{
        const initializeAuth = async ()=>{
            const accessToken = localStorage.getItem(STORAGE_KEYS.ACCESS_TOKEN);
            const refreshToken = localStorage.getItem(STORAGE_KEYS.REFRESH_TOKEN);
            const userData = localStorage.getItem(STORAGE_KEYS.USER_DATA);
            if (accessToken && userData) {
                try {
                    const user = JSON.parse(userData);
                    const tokens = {
                        access_token: accessToken,
                        refresh_token: refreshToken || undefined,
                        token_type: 'bearer'
                    };
                    dispatch({
                        type: 'AUTH_SUCCESS',
                        payload: {
                            user,
                            tokens
                        }
                    });
                    // Set token in API service
                    _apiService.apiService.setAuthToken(accessToken);
                    // Verify token is still valid by fetching current user
                    await getCurrentUser();
                } catch (error) {
                    // Reason: Clear invalid stored data
                    clearStoredAuth();
                }
            }
        };
        initializeAuth();
    }, []);
    /**
   * Clear stored authentication data from localStorage.
   */ const clearStoredAuth = ()=>{
        localStorage.removeItem(STORAGE_KEYS.ACCESS_TOKEN);
        localStorage.removeItem(STORAGE_KEYS.REFRESH_TOKEN);
        localStorage.removeItem(STORAGE_KEYS.USER_DATA);
        _apiService.apiService.setAuthToken(null);
        _apiService.apiService.clearCache(); // Clear any cached authenticated data
    };
    /**
   * Store authentication data in localStorage and API service.
   */ const storeAuthData = (user, tokens)=>{
        localStorage.setItem(STORAGE_KEYS.ACCESS_TOKEN, tokens.access_token);
        if (tokens.refresh_token) {
            localStorage.setItem(STORAGE_KEYS.REFRESH_TOKEN, tokens.refresh_token);
        }
        localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(user));
        // Set token in API service for authenticated requests
        _apiService.apiService.setAuthToken(tokens.access_token);
    };
    /**
   * Make authenticated API request with automatic token refresh.
   */ const authenticatedFetch = async (url, options = {})=>{
        const accessToken = state.tokens?.access_token;
        if (!accessToken) {
            throw new Error('No access token available');
        }
        const response = await fetch(url, {
            ...options,
            headers: {
                ...options.headers,
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
            }
        });
        // If token expired, try to refresh
        if (response.status === 401 && state.tokens?.refresh_token) {
            try {
                await refreshToken();
                // Retry the request with new token
                return fetch(url, {
                    ...options,
                    headers: {
                        ...options.headers,
                        'Authorization': `Bearer ${state.tokens?.access_token}`,
                        'Content-Type': 'application/json'
                    }
                });
            } catch (refreshError) {
                // Refresh failed, logout user
                await logout();
                throw new Error('Session expired. Please log in again.');
            }
        }
        return response;
    };
    /**
   * Login with GitHub OAuth code.
   */ const login = async (code, state_param)=>{
        dispatch({
            type: 'AUTH_START'
        });
        try {
            const response = await fetch(`${API_BASE_URL}/auth/login/github`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    code,
                    state: state_param
                })
            });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Login failed');
            }
            const tokens = await response.json();
            // Get user data
            const userResponse = await fetch(`${API_BASE_URL}/auth/me`, {
                headers: {
                    'Authorization': `Bearer ${tokens.access_token}`
                }
            });
            if (!userResponse.ok) {
                throw new Error('Failed to fetch user data');
            }
            const user = await userResponse.json();
            // Store auth data
            storeAuthData(user, tokens);
            dispatch({
                type: 'AUTH_SUCCESS',
                payload: {
                    user,
                    tokens
                }
            });
        } catch (error) {
            const message = error instanceof Error ? error.message : 'Login failed';
            dispatch({
                type: 'AUTH_FAILURE',
                payload: message
            });
            throw error;
        }
    };
    /**
   * Logout current user.
   */ const logout = async ()=>{
        try {
            // Call logout endpoint if authenticated
            if (state.tokens?.access_token) {
                await authenticatedFetch(`${API_BASE_URL}/auth/logout`, {
                    method: 'POST'
                });
            }
        } catch (error) {
            // Log error but continue with logout
            console.warn('Logout API call failed:', error);
        } finally{
            // Always clear local state and storage
            clearStoredAuth();
            dispatch({
                type: 'AUTH_LOGOUT'
            });
        }
    };
    /**
   * Refresh access token using refresh token.
   */ const refreshToken = async ()=>{
        const refresh_token = state.tokens?.refresh_token;
        if (!refresh_token) {
            throw new Error('No refresh token available');
        }
        try {
            const response = await fetch(`${API_BASE_URL}/auth/refresh`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    refresh_token
                })
            });
            if (!response.ok) {
                throw new Error('Token refresh failed');
            }
            const tokens = await response.json();
            // Update stored tokens
            localStorage.setItem(STORAGE_KEYS.ACCESS_TOKEN, tokens.access_token);
            if (tokens.refresh_token) {
                localStorage.setItem(STORAGE_KEYS.REFRESH_TOKEN, tokens.refresh_token);
            }
            dispatch({
                type: 'AUTH_REFRESH_SUCCESS',
                payload: tokens
            });
        } catch (error) {
            // Refresh failed, logout user
            await logout();
            throw error;
        }
    };
    /**
   * Get current user data from API.
   */ const getCurrentUser = async ()=>{
        try {
            const response = await authenticatedFetch(`${API_BASE_URL}/auth/me`);
            if (!response.ok) {
                throw new Error('Failed to fetch user data');
            }
            const user = await response.json();
            // Update stored user data
            localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(user));
            dispatch({
                type: 'AUTH_UPDATE_USER',
                payload: user
            });
        } catch (error) {
            console.error('Failed to get current user:', error);
            throw error;
        }
    };
    /**
   * Check if user has specific permission.
   */ const hasPermission = (permission, organizationId)=>{
        if (!state.user || !state.isAuthenticated) return false;
        // Superuser has all permissions
        if (state.user.is_superuser) return true;
        // Check user permissions
        if (state.user.permissions) {
            return state.user.permissions.some((p)=>p.name === permission && (!organizationId || !p.organization_id || p.organization_id === organizationId));
        }
        // Check role permissions
        if (state.user.roles) {
            return state.user.roles.some((role)=>role.permissions.some((p)=>p.name === permission && (!organizationId || !p.organization_id || p.organization_id === organizationId)));
        }
        return false;
    };
    /**
   * Check if user has specific role.
   */ const hasRole = (role)=>{
        if (!state.user || !state.isAuthenticated) return false;
        return state.user.roles?.some((r)=>r.name === role) || false;
    };
    /**
   * Check if user has any of the specified roles.
   */ const hasAnyRole = (roles)=>{
        if (!state.user || !state.isAuthenticated) return false;
        return roles.some((role)=>hasRole(role));
    };
    /**
   * Check if user has any of the specified permissions.
   */ const hasAnyPermission = (permissions)=>{
        if (!state.user || !state.isAuthenticated) return false;
        return permissions.some((permission)=>hasPermission(permission));
    };
    /**
   * Get all user permissions (direct + role-based).
   */ const getUserPermissions = ()=>{
        if (!state.user || !state.isAuthenticated) return [];
        const permissions = new Map();
        // Add direct permissions
        if (state.user.permissions) {
            state.user.permissions.forEach((p)=>permissions.set(p.id, p));
        }
        // Add role permissions
        if (state.user.roles) {
            state.user.roles.forEach((role)=>{
                role.permissions.forEach((p)=>permissions.set(p.id, p));
            });
        }
        return Array.from(permissions.values());
    };
    /**
   * Get all user roles.
   */ const getUserRoles = ()=>{
        if (!state.user || !state.isAuthenticated) return [];
        return state.user.roles || [];
    };
    /**
   * Check if user is admin (superuser or has admin role).
   */ const isAdmin = ()=>{
        if (!state.user || !state.isAuthenticated) return false;
        return state.user.is_superuser || hasRole('admin') || hasRole('organization_owner');
    };
    /**
   * Check if user can access a resource with specific action.
   */ const canAccess = (resource, action, organizationId)=>{
        if (!state.user || !state.isAuthenticated) return false;
        // Build permission name from resource and action
        const permissionName = `${action}_${resource}`;
        return hasPermission(permissionName, organizationId);
    };
    /**
   * Login with any supported provider (OAuth2 or SAML).
   */ const loginWithProvider = async (provider, redirectUri)=>{
        dispatch({
            type: 'AUTH_START'
        });
        try {
            // Check if it's an OAuth2 or SAML provider
            const availableProviders = await getAvailableProviders();
            const providerInfo = availableProviders.find((p)=>p.name === provider);
            if (!providerInfo) {
                throw new Error(`Unsupported provider: ${provider}`);
            }
            if (providerInfo.type === 'oauth2') {
                // Handle OAuth2 flow
                const response = await fetch(`${API_BASE_URL}/auth/sso/oauth/${provider}/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        provider,
                        redirect_uri: redirectUri || `${window.location.origin}/auth/callback`,
                        state: generateState()
                    })
                });
                if (!response.ok) {
                    throw new Error('Failed to initiate OAuth login');
                }
                const data = await response.json();
                if (data.success && data.redirect_url) {
                    // Store state for callback validation
                    sessionStorage.setItem('oauth_state', data.state);
                    sessionStorage.setItem('oauth_provider', provider);
                    // Redirect to OAuth provider
                    window.location.href = data.redirect_url;
                } else {
                    throw new Error(data.error || 'OAuth login failed');
                }
            } else if (providerInfo.type === 'saml') {
                // Handle SAML flow
                const response = await fetch(`${API_BASE_URL}/auth/sso/saml/${provider}/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        provider,
                        relay_state: generateState()
                    })
                });
                if (!response.ok) {
                    throw new Error('Failed to initiate SAML login');
                }
                const data = await response.json();
                if (data.success && data.sso_url) {
                    // Store state for callback validation
                    sessionStorage.setItem('saml_state', data.relay_state);
                    sessionStorage.setItem('saml_provider', provider);
                    // Redirect to SAML provider
                    window.location.href = data.sso_url;
                } else {
                    throw new Error(data.error || 'SAML login failed');
                }
            }
        } catch (error) {
            console.error('Provider login error:', error);
            dispatch({
                type: 'AUTH_FAILURE',
                payload: error instanceof Error ? error.message : 'Provider login failed'
            });
            throw error;
        }
    };
    /**
   * Get available SSO providers.
   */ const getAvailableProviders = async ()=>{
        try {
            const response = await fetch(`${API_BASE_URL}/auth/sso/config`);
            if (!response.ok) {
                throw new Error('Failed to fetch SSO providers');
            }
            const data = await response.json();
            // Combine OAuth2 and SAML providers
            return [
                ...data.oauth_providers,
                ...data.saml_providers
            ].filter((provider)=>provider.enabled);
        } catch (error) {
            console.error('Error fetching providers:', error);
            return [];
        }
    };
    /**
   * Generate random state for CSRF protection.
   */ const generateState = ()=>{
        return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    };
    const contextValue = {
        state,
        login,
        loginWithProvider,
        logout,
        refreshToken,
        getCurrentUser,
        getAvailableProviders,
        hasPermission,
        hasRole,
        hasAnyRole,
        hasAnyPermission,
        getUserPermissions,
        getUserRoles,
        isAdmin,
        canAccess
    };
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(AuthContext.Provider, {
        value: contextValue,
        children: children
    });
};
const useAuth = ()=>{
    const context = (0, _react.useContext)(AuthContext);
    if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};
const _default = AuthContext;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXZhbi9EZXNrdG9wL0Rldm9wcy1hcHAtZGV2LWN1cnNvci9mcm9udGVuZC9zcmMvY29udGV4dHMvQXV0aENvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRW5oYW5jZWQgQXV0aGVudGljYXRpb24gY29udGV4dCBmb3IgbWFuYWdpbmcgdXNlciBzZXNzaW9uIHN0YXRlLlxuICogUHJvdmlkZXMgYXV0aGVudGljYXRpb24gc3RhdGUsIHVzZXIgZGF0YSwgYXV0aCBtZXRob2RzLCBhbmQgYmFja2VuZCBpbnRlZ3JhdGlvbi5cbiAqIE9wdGltaXplZCBmb3IgZW50ZXJwcmlzZS1ncmFkZSBhdXRoZW50aWNhdGlvbiBmbG93LlxuICovXG4ndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VSZWR1Y2VyLCB1c2VFZmZlY3QsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGFwaVNlcnZpY2UgfSBmcm9tICdAL3NlcnZpY2VzL2FwaVNlcnZpY2UnO1xuXG4vLyBUeXBlcyBmb3IgYXV0aGVudGljYXRpb24gc3RhdGVcbmludGVyZmFjZSBSb2xlIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkaXNwbGF5X25hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgcHJpb3JpdHk6IG51bWJlcjtcbiAgaXNfc3lzdGVtX3JvbGU6IGJvb2xlYW47XG4gIHBlcm1pc3Npb25zOiBQZXJtaXNzaW9uW107XG59XG5cbmludGVyZmFjZSBQZXJtaXNzaW9uIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkaXNwbGF5X25hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgaXNfc3lzdGVtX3Blcm1pc3Npb246IGJvb2xlYW47XG4gIG9yZ2FuaXphdGlvbl9pZD86IHN0cmluZzsgLy8gT3B0aW9uYWwgb3JnYW5pemF0aW9uIHNjb3BlIGZvciBwZXJtaXNzaW9uXG59XG5cbmludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IG51bWJlcjtcbiAgZ2l0aHViX2lkOiBzdHJpbmc7XG4gIGdpdGh1Yl91c2VybmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nIHwgbnVsbDtcbiAgZnVsbF9uYW1lOiBzdHJpbmcgfCBudWxsO1xuICBhdmF0YXJfdXJsOiBzdHJpbmcgfCBudWxsO1xuICBiaW86IHN0cmluZyB8IG51bGw7XG4gIGNvbXBhbnk6IHN0cmluZyB8IG51bGw7XG4gIGxvY2F0aW9uOiBzdHJpbmcgfCBudWxsO1xuICBibG9nOiBzdHJpbmcgfCBudWxsO1xuICBpc19hY3RpdmU6IGJvb2xlYW47XG4gIGlzX3N1cGVydXNlcjogYm9vbGVhbjtcbiAgY3JlYXRlZF9hdDogc3RyaW5nIHwgbnVsbDtcbiAgdXBkYXRlZF9hdDogc3RyaW5nIHwgbnVsbDtcbiAgbGFzdF9sb2dpbjogc3RyaW5nIHwgbnVsbDtcbiAgcm9sZXM/OiBSb2xlW107XG4gIHBlcm1pc3Npb25zPzogUGVybWlzc2lvbltdO1xuICBvcmdhbml6YXRpb25faWQ/OiBzdHJpbmc7XG4gIC8vIE11bHRpLXByb3ZpZGVyIGF1dGggZmllbGRzXG4gIGF1dGhfcHJvdmlkZXI/OiBzdHJpbmc7XG4gIHByb3ZpZGVyX3VzZXJfaWQ/OiBzdHJpbmc7XG4gIGxpbmtlZF9hY2NvdW50cz86IExpbmtlZEFjY291bnRbXTtcbn1cblxuaW50ZXJmYWNlIExpbmtlZEFjY291bnQge1xuICBwcm92aWRlcjogc3RyaW5nO1xuICBwcm92aWRlcl91c2VyX2lkOiBzdHJpbmc7XG4gIHByb3ZpZGVyX3VzZXJuYW1lPzogc3RyaW5nO1xuICBsaW5rZWRfYXQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEF1dGhUb2tlbnMge1xuICBhY2Nlc3NfdG9rZW46IHN0cmluZztcbiAgcmVmcmVzaF90b2tlbj86IHN0cmluZztcbiAgdG9rZW5fdHlwZTogc3RyaW5nO1xuICBleHBpcmVzX2luPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgQXV0aFN0YXRlIHtcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIHVzZXI6IFVzZXIgfCBudWxsO1xuICB0b2tlbnM6IEF1dGhUb2tlbnMgfCBudWxsO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbn1cblxuLy8gQXV0aCBhY3Rpb24gdHlwZXNcbnR5cGUgQXV0aEFjdGlvbiA9XG4gIHwgeyB0eXBlOiAnQVVUSF9TVEFSVCcgfVxuICB8IHsgdHlwZTogJ0FVVEhfU1VDQ0VTUyc7IHBheWxvYWQ6IHsgdXNlcjogVXNlcjsgdG9rZW5zOiBBdXRoVG9rZW5zIH0gfVxuICB8IHsgdHlwZTogJ0FVVEhfRkFJTFVSRSc7IHBheWxvYWQ6IHN0cmluZyB9XG4gIHwgeyB0eXBlOiAnQVVUSF9MT0dPVVQnIH1cbiAgfCB7IHR5cGU6ICdBVVRIX1JFRlJFU0hfU1VDQ0VTUyc7IHBheWxvYWQ6IEF1dGhUb2tlbnMgfVxuICB8IHsgdHlwZTogJ0FVVEhfVVBEQVRFX1VTRVInOyBwYXlsb2FkOiBVc2VyIH07XG5cbi8vIFByb3ZpZGVyIGluZm9ybWF0aW9uIGludGVyZmFjZVxuaW50ZXJmYWNlIFNTT1Byb3ZpZGVyIHtcbiAgbmFtZTogc3RyaW5nO1xuICBkaXNwbGF5X25hbWU6IHN0cmluZztcbiAgaWNvbjogc3RyaW5nO1xuICBlbmFibGVkOiBib29sZWFuO1xuICB0eXBlOiAnb2F1dGgyJyB8ICdzYW1sJztcbn1cblxuLy8gQXV0aCBjb250ZXh0IGludGVyZmFjZVxuaW50ZXJmYWNlIEF1dGhDb250ZXh0VHlwZSB7XG4gIHN0YXRlOiBBdXRoU3RhdGU7XG4gIGxvZ2luOiAoY29kZTogc3RyaW5nLCBzdGF0ZT86IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgbG9naW5XaXRoUHJvdmlkZXI6IChwcm92aWRlcjogc3RyaW5nLCByZWRpcmVjdFVyaT86IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgbG9nb3V0OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICByZWZyZXNoVG9rZW46ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGdldEN1cnJlbnRVc2VyOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBnZXRBdmFpbGFibGVQcm92aWRlcnM6ICgpID0+IFByb21pc2U8U1NPUHJvdmlkZXJbXT47XG4gIGhhc1Blcm1pc3Npb246IChwZXJtaXNzaW9uOiBzdHJpbmcsIG9yZ2FuaXphdGlvbklkPzogc3RyaW5nKSA9PiBib29sZWFuO1xuICBoYXNSb2xlOiAocm9sZTogc3RyaW5nKSA9PiBib29sZWFuO1xuICBoYXNBbnlSb2xlOiAocm9sZXM6IHN0cmluZ1tdKSA9PiBib29sZWFuO1xuICBoYXNBbnlQZXJtaXNzaW9uOiAocGVybWlzc2lvbnM6IHN0cmluZ1tdKSA9PiBib29sZWFuO1xuICBnZXRVc2VyUGVybWlzc2lvbnM6ICgpID0+IFBlcm1pc3Npb25bXTtcbiAgZ2V0VXNlclJvbGVzOiAoKSA9PiBSb2xlW107XG4gIGlzQWRtaW46ICgpID0+IGJvb2xlYW47XG4gIGNhbkFjY2VzczogKHJlc291cmNlOiBzdHJpbmcsIGFjdGlvbjogc3RyaW5nLCBvcmdhbml6YXRpb25JZD86IHN0cmluZykgPT4gYm9vbGVhbjtcbn1cblxuLy8gSW5pdGlhbCBzdGF0ZVxuY29uc3QgaW5pdGlhbFN0YXRlOiBBdXRoU3RhdGUgPSB7XG4gIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXG4gIGlzTG9hZGluZzogZmFsc2UsXG4gIHVzZXI6IG51bGwsXG4gIHRva2VuczogbnVsbCxcbiAgZXJyb3I6IG51bGwsXG59O1xuXG4vLyBBdXRoIHJlZHVjZXJcbmZ1bmN0aW9uIGF1dGhSZWR1Y2VyKHN0YXRlOiBBdXRoU3RhdGUsIGFjdGlvbjogQXV0aEFjdGlvbik6IEF1dGhTdGF0ZSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdBVVRIX1NUQVJUJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfTtcbiAgICBjYXNlICdBVVRIX1NVQ0NFU1MnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgdXNlcjogYWN0aW9uLnBheWxvYWQudXNlcixcbiAgICAgICAgdG9rZW5zOiBhY3Rpb24ucGF5bG9hZC50b2tlbnMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfTtcbiAgICBjYXNlICdBVVRIX0ZBSUxVUkUnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgIHRva2VuczogbnVsbCxcbiAgICAgICAgZXJyb3I6IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgfTtcbiAgICBjYXNlICdBVVRIX0xPR09VVCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbml0aWFsU3RhdGUsXG4gICAgICB9O1xuICAgIGNhc2UgJ0FVVEhfUkVGUkVTSF9TVUNDRVNTJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICB0b2tlbnM6IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH07XG4gICAgY2FzZSAnQVVUSF9VUERBVEVfVVNFUic6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdXNlcjogYWN0aW9uLnBheWxvYWQsXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuLy8gQ3JlYXRlIGNvbnRleHRcbmNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG5cbi8vIFN0b3JhZ2Uga2V5c1xuY29uc3QgU1RPUkFHRV9LRVlTID0ge1xuICBBQ0NFU1NfVE9LRU46ICdvcHNpZ2h0X2FjY2Vzc190b2tlbicsXG4gIFJFRlJFU0hfVE9LRU46ICdvcHNpZ2h0X3JlZnJlc2hfdG9rZW4nLFxuICBVU0VSX0RBVEE6ICdvcHNpZ2h0X3VzZXJfZGF0YScsXG59IGFzIGNvbnN0O1xuXG4vLyBBUEkgYmFzZSBVUkwgLSBVc2UgcHJvY2Vzcy5lbnYgZm9yIEplc3QgY29tcGF0aWJpbGl0eVxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpL3YxJztcblxuLyoqXG4gKiBBdXRoZW50aWNhdGlvbiBQcm92aWRlciBDb21wb25lbnRcbiAqIFxuICogTWFuYWdlcyBhdXRoZW50aWNhdGlvbiBzdGF0ZSBhbmQgcHJvdmlkZXMgYXV0aCBtZXRob2RzIHRvIGNoaWxkIGNvbXBvbmVudHMuXG4gKiBIYW5kbGVzIHRva2VuIHBlcnNpc3RlbmNlLCBhdXRvbWF0aWMgcmVmcmVzaCwgYW5kIHNlc3Npb24gcmVzdG9yYXRpb24uXG4gKiBcbiAqIEBwYXJhbSBjaGlsZHJlbiAtIENoaWxkIGNvbXBvbmVudHMgdGhhdCBuZWVkIGFjY2VzcyB0byBhdXRoIGNvbnRleHRcbiAqL1xuZXhwb3J0IGNvbnN0IEF1dGhQcm92aWRlcjogUmVhY3QuRkM8eyBjaGlsZHJlbjogUmVhY3ROb2RlIH0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IHVzZVJlZHVjZXIoYXV0aFJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYXV0aGVudGljYXRpb24gc3RhdGUgZnJvbSBzdG9yZWQgdG9rZW5zIG9uIGFwcCBzdGFydC5cbiAgICovXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZUF1dGggPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZUy5BQ0NFU1NfVE9LRU4pO1xuICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVlTLlJFRlJFU0hfVE9LRU4pO1xuICAgICAgY29uc3QgdXNlckRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWVMuVVNFUl9EQVRBKTtcblxuICAgICAgaWYgKGFjY2Vzc1Rva2VuICYmIHVzZXJEYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdXNlciA9IEpTT04ucGFyc2UodXNlckRhdGEpO1xuICAgICAgICAgIGNvbnN0IHRva2VucyA9IHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG9rZW5fdHlwZTogJ2JlYXJlcicsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdBVVRIX1NVQ0NFU1MnLFxuICAgICAgICAgICAgcGF5bG9hZDogeyB1c2VyLCB0b2tlbnMgfSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFNldCB0b2tlbiBpbiBBUEkgc2VydmljZVxuICAgICAgICAgIGFwaVNlcnZpY2Uuc2V0QXV0aFRva2VuKGFjY2Vzc1Rva2VuKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWZXJpZnkgdG9rZW4gaXMgc3RpbGwgdmFsaWQgYnkgZmV0Y2hpbmcgY3VycmVudCB1c2VyXG4gICAgICAgICAgYXdhaXQgZ2V0Q3VycmVudFVzZXIoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBSZWFzb246IENsZWFyIGludmFsaWQgc3RvcmVkIGRhdGFcbiAgICAgICAgICBjbGVhclN0b3JlZEF1dGgoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0aWFsaXplQXV0aCgpO1xuICB9LCBbXSk7XG5cbiAgLyoqXG4gICAqIENsZWFyIHN0b3JlZCBhdXRoZW50aWNhdGlvbiBkYXRhIGZyb20gbG9jYWxTdG9yYWdlLlxuICAgKi9cbiAgY29uc3QgY2xlYXJTdG9yZWRBdXRoID0gKCk6IHZvaWQgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfS0VZUy5BQ0NFU1NfVE9LRU4pO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfS0VZUy5SRUZSRVNIX1RPS0VOKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0tFWVMuVVNFUl9EQVRBKTtcbiAgICBhcGlTZXJ2aWNlLnNldEF1dGhUb2tlbihudWxsKTtcbiAgICBhcGlTZXJ2aWNlLmNsZWFyQ2FjaGUoKTsgLy8gQ2xlYXIgYW55IGNhY2hlZCBhdXRoZW50aWNhdGVkIGRhdGFcbiAgfTtcblxuICAvKipcbiAgICogU3RvcmUgYXV0aGVudGljYXRpb24gZGF0YSBpbiBsb2NhbFN0b3JhZ2UgYW5kIEFQSSBzZXJ2aWNlLlxuICAgKi9cbiAgY29uc3Qgc3RvcmVBdXRoRGF0YSA9ICh1c2VyOiBVc2VyLCB0b2tlbnM6IEF1dGhUb2tlbnMpOiB2b2lkID0+IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuQUNDRVNTX1RPS0VOLCB0b2tlbnMuYWNjZXNzX3Rva2VuKTtcbiAgICBpZiAodG9rZW5zLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZUy5SRUZSRVNIX1RPS0VOLCB0b2tlbnMucmVmcmVzaF90b2tlbik7XG4gICAgfVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZUy5VU0VSX0RBVEEsIEpTT04uc3RyaW5naWZ5KHVzZXIpKTtcbiAgICBcbiAgICAvLyBTZXQgdG9rZW4gaW4gQVBJIHNlcnZpY2UgZm9yIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdHNcbiAgICBhcGlTZXJ2aWNlLnNldEF1dGhUb2tlbih0b2tlbnMuYWNjZXNzX3Rva2VuKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhdXRoZW50aWNhdGVkIEFQSSByZXF1ZXN0IHdpdGggYXV0b21hdGljIHRva2VuIHJlZnJlc2guXG4gICAqL1xuICBjb25zdCBhdXRoZW50aWNhdGVkRmV0Y2ggPSBhc3luYyAoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fVxuICApOiBQcm9taXNlPFJlc3BvbnNlPiA9PiB7XG4gICAgY29uc3QgYWNjZXNzVG9rZW4gPSBzdGF0ZS50b2tlbnM/LmFjY2Vzc190b2tlbjtcbiAgICBcbiAgICBpZiAoIWFjY2Vzc1Rva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIElmIHRva2VuIGV4cGlyZWQsIHRyeSB0byByZWZyZXNoXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxICYmIHN0YXRlLnRva2Vucz8ucmVmcmVzaF90b2tlbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcmVmcmVzaFRva2VuKCk7XG4gICAgICAgIC8vIFJldHJ5IHRoZSByZXF1ZXN0IHdpdGggbmV3IHRva2VuXG4gICAgICAgIHJldHVybiBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3N0YXRlLnRva2Vucz8uYWNjZXNzX3Rva2VufWAsXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAocmVmcmVzaEVycm9yKSB7XG4gICAgICAgIC8vIFJlZnJlc2ggZmFpbGVkLCBsb2dvdXQgdXNlclxuICAgICAgICBhd2FpdCBsb2dvdXQoKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXNzaW9uIGV4cGlyZWQuIFBsZWFzZSBsb2cgaW4gYWdhaW4uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2dpbiB3aXRoIEdpdEh1YiBPQXV0aCBjb2RlLlxuICAgKi9cbiAgY29uc3QgbG9naW4gPSBhc3luYyAoY29kZTogc3RyaW5nLCBzdGF0ZV9wYXJhbT86IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0FVVEhfU1RBUlQnIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hdXRoL2xvZ2luL2dpdGh1YmAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICBzdGF0ZTogc3RhdGVfcGFyYW0sXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5kZXRhaWwgfHwgJ0xvZ2luIGZhaWxlZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2tlbnM6IEF1dGhUb2tlbnMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEdldCB1c2VyIGRhdGFcbiAgICAgIGNvbnN0IHVzZXJSZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXV0aC9tZWAsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2Vucy5hY2Nlc3NfdG9rZW59YCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXVzZXJSZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCB1c2VyIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNlcjogVXNlciA9IGF3YWl0IHVzZXJSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIFN0b3JlIGF1dGggZGF0YVxuICAgICAgc3RvcmVBdXRoRGF0YSh1c2VyLCB0b2tlbnMpO1xuXG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdBVVRIX1NVQ0NFU1MnLFxuICAgICAgICBwYXlsb2FkOiB7IHVzZXIsIHRva2VucyB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdMb2dpbiBmYWlsZWQnO1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnQVVUSF9GQUlMVVJFJywgcGF5bG9hZDogbWVzc2FnZSB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTG9nb3V0IGN1cnJlbnQgdXNlci5cbiAgICovXG4gIGNvbnN0IGxvZ291dCA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2FsbCBsb2dvdXQgZW5kcG9pbnQgaWYgYXV0aGVudGljYXRlZFxuICAgICAgaWYgKHN0YXRlLnRva2Vucz8uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgIGF3YWl0IGF1dGhlbnRpY2F0ZWRGZXRjaChgJHtBUElfQkFTRV9VUkx9L2F1dGgvbG9nb3V0YCwge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gTG9nIGVycm9yIGJ1dCBjb250aW51ZSB3aXRoIGxvZ291dFxuICAgICAgY29uc29sZS53YXJuKCdMb2dvdXQgQVBJIGNhbGwgZmFpbGVkOicsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gQWx3YXlzIGNsZWFyIGxvY2FsIHN0YXRlIGFuZCBzdG9yYWdlXG4gICAgICBjbGVhclN0b3JlZEF1dGgoKTtcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ0FVVEhfTE9HT1VUJyB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggYWNjZXNzIHRva2VuIHVzaW5nIHJlZnJlc2ggdG9rZW4uXG4gICAqL1xuICBjb25zdCByZWZyZXNoVG9rZW4gPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgY29uc3QgcmVmcmVzaF90b2tlbiA9IHN0YXRlLnRva2Vucz8ucmVmcmVzaF90b2tlbjtcbiAgICBcbiAgICBpZiAoIXJlZnJlc2hfdG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVmcmVzaCB0b2tlbiBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2F1dGgvcmVmcmVzaGAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcmVmcmVzaF90b2tlbixcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRva2VuczogQXV0aFRva2VucyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gVXBkYXRlIHN0b3JlZCB0b2tlbnNcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZUy5BQ0NFU1NfVE9LRU4sIHRva2Vucy5hY2Nlc3NfdG9rZW4pO1xuICAgICAgaWYgKHRva2Vucy5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZUy5SRUZSRVNIX1RPS0VOLCB0b2tlbnMucmVmcmVzaF90b2tlbik7XG4gICAgICB9XG5cbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ0FVVEhfUkVGUkVTSF9TVUNDRVNTJyxcbiAgICAgICAgcGF5bG9hZDogdG9rZW5zLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFJlZnJlc2ggZmFpbGVkLCBsb2dvdXQgdXNlclxuICAgICAgYXdhaXQgbG9nb3V0KCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHVzZXIgZGF0YSBmcm9tIEFQSS5cbiAgICovXG4gIGNvbnN0IGdldEN1cnJlbnRVc2VyID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0ZWRGZXRjaChgJHtBUElfQkFTRV9VUkx9L2F1dGgvbWVgKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCB1c2VyIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNlcjogVXNlciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gVXBkYXRlIHN0b3JlZCB1c2VyIGRhdGFcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZUy5VU0VSX0RBVEEsIEpTT04uc3RyaW5naWZ5KHVzZXIpKTtcblxuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnQVVUSF9VUERBVEVfVVNFUicsXG4gICAgICAgIHBheWxvYWQ6IHVzZXIsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBjdXJyZW50IHVzZXI6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB1c2VyIGhhcyBzcGVjaWZpYyBwZXJtaXNzaW9uLlxuICAgKi9cbiAgY29uc3QgaGFzUGVybWlzc2lvbiA9IChwZXJtaXNzaW9uOiBzdHJpbmcsIG9yZ2FuaXphdGlvbklkPzogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFzdGF0ZS51c2VyIHx8ICFzdGF0ZS5pc0F1dGhlbnRpY2F0ZWQpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBTdXBlcnVzZXIgaGFzIGFsbCBwZXJtaXNzaW9uc1xuICAgIGlmIChzdGF0ZS51c2VyLmlzX3N1cGVydXNlcikgcmV0dXJuIHRydWU7XG4gICAgXG4gICAgLy8gQ2hlY2sgdXNlciBwZXJtaXNzaW9uc1xuICAgIGlmIChzdGF0ZS51c2VyLnBlcm1pc3Npb25zKSB7XG4gICAgICByZXR1cm4gc3RhdGUudXNlci5wZXJtaXNzaW9ucy5zb21lKHAgPT4gXG4gICAgICAgIHAubmFtZSA9PT0gcGVybWlzc2lvbiAmJiBcbiAgICAgICAgKCFvcmdhbml6YXRpb25JZCB8fCAhcC5vcmdhbml6YXRpb25faWQgfHwgcC5vcmdhbml6YXRpb25faWQgPT09IG9yZ2FuaXphdGlvbklkKVxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgcm9sZSBwZXJtaXNzaW9uc1xuICAgIGlmIChzdGF0ZS51c2VyLnJvbGVzKSB7XG4gICAgICByZXR1cm4gc3RhdGUudXNlci5yb2xlcy5zb21lKHJvbGUgPT4gXG4gICAgICAgIHJvbGUucGVybWlzc2lvbnMuc29tZShwID0+IFxuICAgICAgICAgIHAubmFtZSA9PT0gcGVybWlzc2lvbiAmJiBcbiAgICAgICAgICAoIW9yZ2FuaXphdGlvbklkIHx8ICFwLm9yZ2FuaXphdGlvbl9pZCB8fCBwLm9yZ2FuaXphdGlvbl9pZCA9PT0gb3JnYW5pemF0aW9uSWQpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdXNlciBoYXMgc3BlY2lmaWMgcm9sZS5cbiAgICovXG4gIGNvbnN0IGhhc1JvbGUgPSAocm9sZTogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFzdGF0ZS51c2VyIHx8ICFzdGF0ZS5pc0F1dGhlbnRpY2F0ZWQpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICByZXR1cm4gc3RhdGUudXNlci5yb2xlcz8uc29tZShyID0+IHIubmFtZSA9PT0gcm9sZSkgfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHVzZXIgaGFzIGFueSBvZiB0aGUgc3BlY2lmaWVkIHJvbGVzLlxuICAgKi9cbiAgY29uc3QgaGFzQW55Um9sZSA9IChyb2xlczogc3RyaW5nW10pOiBib29sZWFuID0+IHtcbiAgICBpZiAoIXN0YXRlLnVzZXIgfHwgIXN0YXRlLmlzQXV0aGVudGljYXRlZCkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIHJldHVybiByb2xlcy5zb21lKHJvbGUgPT4gaGFzUm9sZShyb2xlKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHVzZXIgaGFzIGFueSBvZiB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb25zLlxuICAgKi9cbiAgY29uc3QgaGFzQW55UGVybWlzc2lvbiA9IChwZXJtaXNzaW9uczogc3RyaW5nW10pOiBib29sZWFuID0+IHtcbiAgICBpZiAoIXN0YXRlLnVzZXIgfHwgIXN0YXRlLmlzQXV0aGVudGljYXRlZCkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIHJldHVybiBwZXJtaXNzaW9ucy5zb21lKHBlcm1pc3Npb24gPT4gaGFzUGVybWlzc2lvbihwZXJtaXNzaW9uKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdXNlciBwZXJtaXNzaW9ucyAoZGlyZWN0ICsgcm9sZS1iYXNlZCkuXG4gICAqL1xuICBjb25zdCBnZXRVc2VyUGVybWlzc2lvbnMgPSAoKTogUGVybWlzc2lvbltdID0+IHtcbiAgICBpZiAoIXN0YXRlLnVzZXIgfHwgIXN0YXRlLmlzQXV0aGVudGljYXRlZCkgcmV0dXJuIFtdO1xuICAgIFxuICAgIGNvbnN0IHBlcm1pc3Npb25zID0gbmV3IE1hcDxzdHJpbmcsIFBlcm1pc3Npb24+KCk7XG4gICAgXG4gICAgLy8gQWRkIGRpcmVjdCBwZXJtaXNzaW9uc1xuICAgIGlmIChzdGF0ZS51c2VyLnBlcm1pc3Npb25zKSB7XG4gICAgICBzdGF0ZS51c2VyLnBlcm1pc3Npb25zLmZvckVhY2gocCA9PiBwZXJtaXNzaW9ucy5zZXQocC5pZCwgcCkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgcm9sZSBwZXJtaXNzaW9uc1xuICAgIGlmIChzdGF0ZS51c2VyLnJvbGVzKSB7XG4gICAgICBzdGF0ZS51c2VyLnJvbGVzLmZvckVhY2gocm9sZSA9PiB7XG4gICAgICAgIHJvbGUucGVybWlzc2lvbnMuZm9yRWFjaChwID0+IHBlcm1pc3Npb25zLnNldChwLmlkLCBwKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIEFycmF5LmZyb20ocGVybWlzc2lvbnMudmFsdWVzKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHVzZXIgcm9sZXMuXG4gICAqL1xuICBjb25zdCBnZXRVc2VyUm9sZXMgPSAoKTogUm9sZVtdID0+IHtcbiAgICBpZiAoIXN0YXRlLnVzZXIgfHwgIXN0YXRlLmlzQXV0aGVudGljYXRlZCkgcmV0dXJuIFtdO1xuICAgIFxuICAgIHJldHVybiBzdGF0ZS51c2VyLnJvbGVzIHx8IFtdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB1c2VyIGlzIGFkbWluIChzdXBlcnVzZXIgb3IgaGFzIGFkbWluIHJvbGUpLlxuICAgKi9cbiAgY29uc3QgaXNBZG1pbiA9ICgpOiBib29sZWFuID0+IHtcbiAgICBpZiAoIXN0YXRlLnVzZXIgfHwgIXN0YXRlLmlzQXV0aGVudGljYXRlZCkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIHJldHVybiBzdGF0ZS51c2VyLmlzX3N1cGVydXNlciB8fCBoYXNSb2xlKCdhZG1pbicpIHx8IGhhc1JvbGUoJ29yZ2FuaXphdGlvbl9vd25lcicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB1c2VyIGNhbiBhY2Nlc3MgYSByZXNvdXJjZSB3aXRoIHNwZWNpZmljIGFjdGlvbi5cbiAgICovXG4gIGNvbnN0IGNhbkFjY2VzcyA9IChyZXNvdXJjZTogc3RyaW5nLCBhY3Rpb246IHN0cmluZywgb3JnYW5pemF0aW9uSWQ/OiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICBpZiAoIXN0YXRlLnVzZXIgfHwgIXN0YXRlLmlzQXV0aGVudGljYXRlZCkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIEJ1aWxkIHBlcm1pc3Npb24gbmFtZSBmcm9tIHJlc291cmNlIGFuZCBhY3Rpb25cbiAgICBjb25zdCBwZXJtaXNzaW9uTmFtZSA9IGAke2FjdGlvbn1fJHtyZXNvdXJjZX1gO1xuICAgIFxuICAgIHJldHVybiBoYXNQZXJtaXNzaW9uKHBlcm1pc3Npb25OYW1lLCBvcmdhbml6YXRpb25JZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvZ2luIHdpdGggYW55IHN1cHBvcnRlZCBwcm92aWRlciAoT0F1dGgyIG9yIFNBTUwpLlxuICAgKi9cbiAgY29uc3QgbG9naW5XaXRoUHJvdmlkZXIgPSBhc3luYyAocHJvdmlkZXI6IHN0cmluZywgcmVkaXJlY3RVcmk/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdBVVRIX1NUQVJUJyB9KTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGFuIE9BdXRoMiBvciBTQU1MIHByb3ZpZGVyXG4gICAgICBjb25zdCBhdmFpbGFibGVQcm92aWRlcnMgPSBhd2FpdCBnZXRBdmFpbGFibGVQcm92aWRlcnMoKTtcbiAgICAgIGNvbnN0IHByb3ZpZGVySW5mbyA9IGF2YWlsYWJsZVByb3ZpZGVycy5maW5kKHAgPT4gcC5uYW1lID09PSBwcm92aWRlcik7XG4gICAgICBcbiAgICAgIGlmICghcHJvdmlkZXJJbmZvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcHJvdmlkZXI6ICR7cHJvdmlkZXJ9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm92aWRlckluZm8udHlwZSA9PT0gJ29hdXRoMicpIHtcbiAgICAgICAgLy8gSGFuZGxlIE9BdXRoMiBmbG93XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hdXRoL3Nzby9vYXV0aC8ke3Byb3ZpZGVyfS9sb2dpbmAsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICByZWRpcmVjdF91cmk6IHJlZGlyZWN0VXJpIHx8IGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59L2F1dGgvY2FsbGJhY2tgLFxuICAgICAgICAgICAgc3RhdGU6IGdlbmVyYXRlU3RhdGUoKVxuICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhdGUgT0F1dGggbG9naW4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzICYmIGRhdGEucmVkaXJlY3RfdXJsKSB7XG4gICAgICAgICAgLy8gU3RvcmUgc3RhdGUgZm9yIGNhbGxiYWNrIHZhbGlkYXRpb25cbiAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdvYXV0aF9zdGF0ZScsIGRhdGEuc3RhdGUpO1xuICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ29hdXRoX3Byb3ZpZGVyJywgcHJvdmlkZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlZGlyZWN0IHRvIE9BdXRoIHByb3ZpZGVyXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkYXRhLnJlZGlyZWN0X3VybDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnT0F1dGggbG9naW4gZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvdmlkZXJJbmZvLnR5cGUgPT09ICdzYW1sJykge1xuICAgICAgICAvLyBIYW5kbGUgU0FNTCBmbG93XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hdXRoL3Nzby9zYW1sLyR7cHJvdmlkZXJ9L2xvZ2luYCwge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIHJlbGF5X3N0YXRlOiBnZW5lcmF0ZVN0YXRlKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGluaXRpYXRlIFNBTUwgbG9naW4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzICYmIGRhdGEuc3NvX3VybCkge1xuICAgICAgICAgIC8vIFN0b3JlIHN0YXRlIGZvciBjYWxsYmFjayB2YWxpZGF0aW9uXG4gICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnc2FtbF9zdGF0ZScsIGRhdGEucmVsYXlfc3RhdGUpO1xuICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ3NhbWxfcHJvdmlkZXInLCBwcm92aWRlcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVkaXJlY3QgdG8gU0FNTCBwcm92aWRlclxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZGF0YS5zc29fdXJsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yIHx8ICdTQU1MIGxvZ2luIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb3ZpZGVyIGxvZ2luIGVycm9yOicsIGVycm9yKTtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ0FVVEhfRkFJTFVSRScsXG4gICAgICAgIHBheWxvYWQ6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Byb3ZpZGVyIGxvZ2luIGZhaWxlZCcsXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGF2YWlsYWJsZSBTU08gcHJvdmlkZXJzLlxuICAgKi9cbiAgY29uc3QgZ2V0QXZhaWxhYmxlUHJvdmlkZXJzID0gYXN5bmMgKCk6IFByb21pc2U8U1NPUHJvdmlkZXJbXT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXV0aC9zc28vY29uZmlnYCk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggU1NPIHByb3ZpZGVycycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICAvLyBDb21iaW5lIE9BdXRoMiBhbmQgU0FNTCBwcm92aWRlcnNcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC4uLmRhdGEub2F1dGhfcHJvdmlkZXJzLFxuICAgICAgICAuLi5kYXRhLnNhbWxfcHJvdmlkZXJzXG4gICAgICBdLmZpbHRlcihwcm92aWRlciA9PiBwcm92aWRlci5lbmFibGVkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvdmlkZXJzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHJhbmRvbSBzdGF0ZSBmb3IgQ1NSRiBwcm90ZWN0aW9uLlxuICAgKi9cbiAgY29uc3QgZ2VuZXJhdGVTdGF0ZSA9ICgpOiBzdHJpbmcgPT4ge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpICsgXG4gICAgICAgICAgIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gIH07XG5cbiAgY29uc3QgY29udGV4dFZhbHVlOiBBdXRoQ29udGV4dFR5cGUgPSB7XG4gICAgc3RhdGUsXG4gICAgbG9naW4sXG4gICAgbG9naW5XaXRoUHJvdmlkZXIsXG4gICAgbG9nb3V0LFxuICAgIHJlZnJlc2hUb2tlbixcbiAgICBnZXRDdXJyZW50VXNlcixcbiAgICBnZXRBdmFpbGFibGVQcm92aWRlcnMsXG4gICAgaGFzUGVybWlzc2lvbixcbiAgICBoYXNSb2xlLFxuICAgIGhhc0FueVJvbGUsXG4gICAgaGFzQW55UGVybWlzc2lvbixcbiAgICBnZXRVc2VyUGVybWlzc2lvbnMsXG4gICAgZ2V0VXNlclJvbGVzLFxuICAgIGlzQWRtaW4sXG4gICAgY2FuQWNjZXNzLFxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEF1dGhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0VmFsdWV9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXV0aENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG4vKipcbiAqIEhvb2sgdG8gYWNjZXNzIGF1dGhlbnRpY2F0aW9uIGNvbnRleHQuXG4gKiBcbiAqIEByZXR1cm5zIEF1dGhDb250ZXh0VHlwZSAtIEF1dGhlbnRpY2F0aW9uIHN0YXRlIGFuZCBtZXRob2RzXG4gKiBAdGhyb3dzIEVycm9yIGlmIHVzZWQgb3V0c2lkZSBBdXRoUHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHVzZUF1dGggPSAoKTogQXV0aENvbnRleHRUeXBlID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQXV0aENvbnRleHQpO1xuICBcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlcicpO1xuICB9XG4gIFxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGhDb250ZXh0OyAiXSwibmFtZXMiOlsiQXV0aFByb3ZpZGVyIiwidXNlQXV0aCIsImluaXRpYWxTdGF0ZSIsImlzQXV0aGVudGljYXRlZCIsImlzTG9hZGluZyIsInVzZXIiLCJ0b2tlbnMiLCJlcnJvciIsImF1dGhSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJ0eXBlIiwicGF5bG9hZCIsIkF1dGhDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVuZGVmaW5lZCIsIlNUT1JBR0VfS0VZUyIsIkFDQ0VTU19UT0tFTiIsIlJFRlJFU0hfVE9LRU4iLCJVU0VSX0RBVEEiLCJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMIiwiY2hpbGRyZW4iLCJkaXNwYXRjaCIsInVzZVJlZHVjZXIiLCJ1c2VFZmZlY3QiLCJpbml0aWFsaXplQXV0aCIsImFjY2Vzc1Rva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInJlZnJlc2hUb2tlbiIsInVzZXJEYXRhIiwiSlNPTiIsInBhcnNlIiwiYWNjZXNzX3Rva2VuIiwicmVmcmVzaF90b2tlbiIsInRva2VuX3R5cGUiLCJhcGlTZXJ2aWNlIiwic2V0QXV0aFRva2VuIiwiZ2V0Q3VycmVudFVzZXIiLCJjbGVhclN0b3JlZEF1dGgiLCJyZW1vdmVJdGVtIiwiY2xlYXJDYWNoZSIsInN0b3JlQXV0aERhdGEiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiYXV0aGVudGljYXRlZEZldGNoIiwidXJsIiwib3B0aW9ucyIsIkVycm9yIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJzdGF0dXMiLCJyZWZyZXNoRXJyb3IiLCJsb2dvdXQiLCJsb2dpbiIsImNvZGUiLCJzdGF0ZV9wYXJhbSIsIm1ldGhvZCIsImJvZHkiLCJvayIsImpzb24iLCJkZXRhaWwiLCJ1c2VyUmVzcG9uc2UiLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iLCJoYXNQZXJtaXNzaW9uIiwicGVybWlzc2lvbiIsIm9yZ2FuaXphdGlvbklkIiwiaXNfc3VwZXJ1c2VyIiwicGVybWlzc2lvbnMiLCJzb21lIiwicCIsIm5hbWUiLCJvcmdhbml6YXRpb25faWQiLCJyb2xlcyIsInJvbGUiLCJoYXNSb2xlIiwiciIsImhhc0FueVJvbGUiLCJoYXNBbnlQZXJtaXNzaW9uIiwiZ2V0VXNlclBlcm1pc3Npb25zIiwiTWFwIiwiZm9yRWFjaCIsInNldCIsImlkIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiZ2V0VXNlclJvbGVzIiwiaXNBZG1pbiIsImNhbkFjY2VzcyIsInJlc291cmNlIiwicGVybWlzc2lvbk5hbWUiLCJsb2dpbldpdGhQcm92aWRlciIsInByb3ZpZGVyIiwicmVkaXJlY3RVcmkiLCJhdmFpbGFibGVQcm92aWRlcnMiLCJnZXRBdmFpbGFibGVQcm92aWRlcnMiLCJwcm92aWRlckluZm8iLCJmaW5kIiwicmVkaXJlY3RfdXJpIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJnZW5lcmF0ZVN0YXRlIiwiZGF0YSIsInN1Y2Nlc3MiLCJyZWRpcmVjdF91cmwiLCJzZXNzaW9uU3RvcmFnZSIsImhyZWYiLCJyZWxheV9zdGF0ZSIsInNzb191cmwiLCJvYXV0aF9wcm92aWRlcnMiLCJzYW1sX3Byb3ZpZGVycyIsImZpbHRlciIsImVuYWJsZWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJjb250ZXh0VmFsdWUiLCJQcm92aWRlciIsInZhbHVlIiwiY29udGV4dCIsInVzZUNvbnRleHQiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUMsR0FDRDs7Ozs7Ozs7Ozs7O0lBMkxhQSxZQUFZO2VBQVpBOztJQTBnQmIsT0FBMkI7ZUFBM0I7O0lBVmFDLE9BQU87ZUFBUEE7Ozs7K0RBenJCc0U7NEJBQ3hEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyRzNCLGdCQUFnQjtBQUNoQixNQUFNQyxlQUEwQjtJQUM5QkMsaUJBQWlCO0lBQ2pCQyxXQUFXO0lBQ1hDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxPQUFPO0FBQ1Q7QUFFQSxlQUFlO0FBQ2YsU0FBU0MsWUFBWUMsS0FBZ0IsRUFBRUMsTUFBa0I7SUFDdkQsT0FBUUEsT0FBT0MsSUFBSTtRQUNqQixLQUFLO1lBQ0gsT0FBTztnQkFDTCxHQUFHRixLQUFLO2dCQUNSTCxXQUFXO2dCQUNYRyxPQUFPO1lBQ1Q7UUFDRixLQUFLO1lBQ0gsT0FBTztnQkFDTCxHQUFHRSxLQUFLO2dCQUNSTixpQkFBaUI7Z0JBQ2pCQyxXQUFXO2dCQUNYQyxNQUFNSyxPQUFPRSxPQUFPLENBQUNQLElBQUk7Z0JBQ3pCQyxRQUFRSSxPQUFPRSxPQUFPLENBQUNOLE1BQU07Z0JBQzdCQyxPQUFPO1lBQ1Q7UUFDRixLQUFLO1lBQ0gsT0FBTztnQkFDTCxHQUFHRSxLQUFLO2dCQUNSTixpQkFBaUI7Z0JBQ2pCQyxXQUFXO2dCQUNYQyxNQUFNO2dCQUNOQyxRQUFRO2dCQUNSQyxPQUFPRyxPQUFPRSxPQUFPO1lBQ3ZCO1FBQ0YsS0FBSztZQUNILE9BQU87Z0JBQ0wsR0FBR1YsWUFBWTtZQUNqQjtRQUNGLEtBQUs7WUFDSCxPQUFPO2dCQUNMLEdBQUdPLEtBQUs7Z0JBQ1JILFFBQVFJLE9BQU9FLE9B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