{"version":3,"sources":["/Users/pavan/Desktop/Devops-app-dev-cursor/frontend/src/contexts/AuthContext.tsx"],"sourcesContent":["/**\n * Authentication context for managing user session state.\n * Provides authentication state, user data, and auth methods to components.\n */\n'use client';\n\nimport React, { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';\nimport { \n  APIError, \n  NetworkError, \n  TokenError, \n  ErrorLogger,\n  AppError,\n  ErrorType,\n  handleFetchError,\n  createNetworkError \n} from '../utils/errorHandling';\nimport { \n  TokenSecurity, \n  CSRFProtection,\n  InputValidator,\n  RateLimiter \n} from '../utils/security';\n\n// Types for authentication state\ninterface Role {\n  id: string;\n  name: string;\n  display_name: string;\n  description: string;\n  priority: number;\n  is_system_role: boolean;\n  permissions: Permission[];\n}\n\ninterface Permission {\n  id: string;\n  name: string;\n  display_name: string;\n  description: string;\n  category: string;\n  is_system_permission: boolean;\n}\n\ninterface User {\n  id: number;\n  github_id: string;\n  github_username: string;\n  email: string | null;\n  full_name: string | null;\n  avatar_url: string | null;\n  bio: string | null;\n  company: string | null;\n  location: string | null;\n  blog: string | null;\n  is_active: boolean;\n  is_superuser: boolean;\n  created_at: string | null;\n  updated_at: string | null;\n  last_login: string | null;\n  roles?: Role[];\n  permissions?: Permission[];\n  organization_id?: string;\n}\n\ninterface AuthTokens {\n  access_token: string;\n  refresh_token?: string;\n  token_type: string;\n  expires_in?: number;\n}\n\ninterface AuthState {\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  user: User | null;\n  tokens: AuthTokens | null;\n  error: string | null;\n}\n\n// Auth action types\ntype AuthAction =\n  | { type: 'AUTH_START' }\n  | { type: 'AUTH_SUCCESS'; payload: { user: User; tokens: AuthTokens } }\n  | { type: 'AUTH_FAILURE'; payload: string }\n  | { type: 'AUTH_LOGOUT' }\n  | { type: 'AUTH_REFRESH_SUCCESS'; payload: AuthTokens }\n  | { type: 'AUTH_UPDATE_USER'; payload: User };\n\n// Auth context interface\ninterface AuthContextType {\n  state: AuthState;\n  login: (code: string, state?: string) => Promise<void>;\n  logout: () => Promise<void>;\n  refreshToken: () => Promise<void>;\n  getCurrentUser: () => Promise<void>;\n  hasPermission: (permission: string, organizationId?: string) => boolean;\n  hasRole: (role: string) => boolean;\n  hasAnyRole: (roles: string[]) => boolean;\n  hasAnyPermission: (permissions: string[]) => boolean;\n  getUserPermissions: () => Permission[];\n  getUserRoles: () => Role[];\n  isAdmin: () => boolean;\n  canAccess: (resource: string, action: string, organizationId?: string) => boolean;\n}\n\n// Initial state\nconst initialState: AuthState = {\n  isAuthenticated: false,\n  isLoading: false,\n  user: null,\n  tokens: null,\n  error: null,\n};\n\n// Auth reducer\nfunction authReducer(state: AuthState, action: AuthAction): AuthState {\n  switch (action.type) {\n    case 'AUTH_START':\n      return {\n        ...state,\n        isLoading: true,\n        error: null,\n      };\n    case 'AUTH_SUCCESS':\n      return {\n        ...state,\n        isAuthenticated: true,\n        isLoading: false,\n        user: action.payload.user,\n        tokens: action.payload.tokens,\n        error: null,\n      };\n    case 'AUTH_FAILURE':\n      return {\n        ...state,\n        isAuthenticated: false,\n        isLoading: false,\n        user: null,\n        tokens: null,\n        error: action.payload,\n      };\n    case 'AUTH_LOGOUT':\n      return {\n        ...initialState,\n      };\n    case 'AUTH_REFRESH_SUCCESS':\n      return {\n        ...state,\n        tokens: action.payload,\n        error: null,\n      };\n    case 'AUTH_UPDATE_USER':\n      return {\n        ...state,\n        user: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n\n// Create context\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// Storage keys\nconst STORAGE_KEYS = {\n  ACCESS_TOKEN: 'opsight_access_token',\n  REFRESH_TOKEN: 'opsight_refresh_token',\n  USER_DATA: 'opsight_user_data',\n} as const;\n\n// API base URL - Use process.env for Jest compatibility\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:8000/api/v1';\n\n/**\n * Authentication Provider Component\n * \n * Manages authentication state and provides auth methods to child components.\n * Handles token persistence, automatic refresh, and session restoration.\n * \n * @param children - Child components that need access to auth context\n */\nexport const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  /**\n   * Initialize authentication state from stored tokens on app start.\n   */\n  useEffect(() => {\n    const initializeAuth = async () => {\n      const accessToken = localStorage.getItem(STORAGE_KEYS.ACCESS_TOKEN);\n      const refreshToken = localStorage.getItem(STORAGE_KEYS.REFRESH_TOKEN);\n      const userData = localStorage.getItem(STORAGE_KEYS.USER_DATA);\n\n      if (accessToken && userData) {\n        try {\n          const user = JSON.parse(userData);\n          const tokens = {\n            access_token: accessToken,\n            refresh_token: refreshToken || undefined,\n            token_type: 'bearer',\n          };\n\n          dispatch({\n            type: 'AUTH_SUCCESS',\n            payload: { user, tokens },\n          });\n\n          // Verify token is still valid by fetching current user\n          await getCurrentUser();\n        } catch (error) {\n          // Reason: Clear invalid stored data\n          clearStoredAuth();\n        }\n      }\n    };\n\n    initializeAuth();\n  }, []);\n\n  /**\n   * Clear stored authentication data from localStorage.\n   */\n  const clearStoredAuth = (): void => {\n    localStorage.removeItem(STORAGE_KEYS.ACCESS_TOKEN);\n    localStorage.removeItem(STORAGE_KEYS.REFRESH_TOKEN);\n    localStorage.removeItem(STORAGE_KEYS.USER_DATA);\n  };\n\n  /**\n   * Store authentication data in localStorage.\n   */\n  const storeAuthData = (user: User, tokens: AuthTokens): void => {\n    localStorage.setItem(STORAGE_KEYS.ACCESS_TOKEN, tokens.access_token);\n    if (tokens.refresh_token) {\n      localStorage.setItem(STORAGE_KEYS.REFRESH_TOKEN, tokens.refresh_token);\n    }\n    localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(user));\n  };\n\n  /**\n   * Make authenticated API request with automatic token refresh.\n   */\n  const authenticatedFetch = async (\n    url: string,\n    options: RequestInit = {}\n  ): Promise<Response> => {\n    const accessToken = state.tokens?.access_token;\n    \n    if (!accessToken) {\n      throw new Error('No access token available');\n    }\n\n    const response = await fetch(url, {\n      ...options,\n      headers: {\n        ...options.headers,\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n      },\n    });\n\n    // If token expired, try to refresh\n    if (response.status === 401 && state.tokens?.refresh_token) {\n      try {\n        await refreshToken();\n        // Retry the request with new token\n        return fetch(url, {\n          ...options,\n          headers: {\n            ...options.headers,\n            'Authorization': `Bearer ${state.tokens?.access_token}`,\n            'Content-Type': 'application/json',\n          },\n        });\n      } catch (refreshError) {\n        // Refresh failed, logout user\n        await logout();\n        throw new Error('Session expired. Please log in again.');\n      }\n    }\n\n    return response;\n  };\n\n  /**\n   * Login with GitHub OAuth code.\n   */\n  const login = async (code: string, state_param?: string): Promise<void> => {\n    dispatch({ type: 'AUTH_START' });\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/auth/login/github`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          code,\n          state: state_param,\n        }),\n      });\n\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Login failed');\n      }\n\n      const tokens: AuthTokens = await response.json();\n\n      // Get user data\n      const userResponse = await fetch(`${API_BASE_URL}/auth/me`, {\n        headers: {\n          'Authorization': `Bearer ${tokens.access_token}`,\n        },\n      });\n\n      if (!userResponse.ok) {\n        throw new Error('Failed to fetch user data');\n      }\n\n      const user: User = await userResponse.json();\n\n      // Store auth data\n      storeAuthData(user, tokens);\n\n      dispatch({\n        type: 'AUTH_SUCCESS',\n        payload: { user, tokens },\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Login failed';\n      dispatch({ type: 'AUTH_FAILURE', payload: message });\n      throw error;\n    }\n  };\n\n  /**\n   * Logout current user.\n   */\n  const logout = async (): Promise<void> => {\n    try {\n      // Call logout endpoint if authenticated\n      if (state.tokens?.access_token) {\n        await authenticatedFetch(`${API_BASE_URL}/auth/logout`, {\n          method: 'POST',\n        });\n      }\n    } catch (error) {\n      // Log error but continue with logout\n      console.warn('Logout API call failed:', error);\n    } finally {\n      // Always clear local state and storage\n      clearStoredAuth();\n      dispatch({ type: 'AUTH_LOGOUT' });\n    }\n  };\n\n  /**\n   * Refresh access token using refresh token.\n   */\n  const refreshToken = async (): Promise<void> => {\n    const refresh_token = state.tokens?.refresh_token;\n    \n    if (!refresh_token) {\n      throw new Error('No refresh token available');\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/auth/refresh`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          refresh_token,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error('Token refresh failed');\n      }\n\n      const tokens: AuthTokens = await response.json();\n\n      // Update stored tokens\n      localStorage.setItem(STORAGE_KEYS.ACCESS_TOKEN, tokens.access_token);\n      if (tokens.refresh_token) {\n        localStorage.setItem(STORAGE_KEYS.REFRESH_TOKEN, tokens.refresh_token);\n      }\n\n      dispatch({\n        type: 'AUTH_REFRESH_SUCCESS',\n        payload: tokens,\n      });\n    } catch (error) {\n      // Refresh failed, logout user\n      await logout();\n      throw error;\n    }\n  };\n\n  /**\n   * Get current user data from API.\n   */\n  const getCurrentUser = async (): Promise<void> => {\n    try {\n      const response = await authenticatedFetch(`${API_BASE_URL}/auth/me`);\n\n      if (!response.ok) {\n        throw new Error('Failed to fetch user data');\n      }\n\n      const user: User = await response.json();\n\n      // Update stored user data\n      localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(user));\n\n      dispatch({\n        type: 'AUTH_UPDATE_USER',\n        payload: user,\n      });\n    } catch (error) {\n      console.error('Failed to get current user:', error);\n      throw error;\n    }\n  };\n\n  /**\n   * Check if user has specific permission.\n   */\n  const hasPermission = (permission: string, organizationId?: string): boolean => {\n    if (!state.user || !state.isAuthenticated) return false;\n    \n    // Superuser has all permissions\n    if (state.user.is_superuser) return true;\n    \n    // Check user permissions\n    if (state.user.permissions) {\n      return state.user.permissions.some(p => \n        p.name === permission && \n        (!organizationId || !p.organization_id || p.organization_id === organizationId)\n      );\n    }\n    \n    // Check role permissions\n    if (state.user.roles) {\n      return state.user.roles.some(role => \n        role.permissions.some(p => \n          p.name === permission && \n          (!organizationId || !p.organization_id || p.organization_id === organizationId)\n        )\n      );\n    }\n    \n    return false;\n  };\n\n  /**\n   * Check if user has specific role.\n   */\n  const hasRole = (role: string): boolean => {\n    if (!state.user || !state.isAuthenticated) return false;\n    \n    return state.user.roles?.some(r => r.name === role) || false;\n  };\n\n  /**\n   * Check if user has any of the specified roles.\n   */\n  const hasAnyRole = (roles: string[]): boolean => {\n    if (!state.user || !state.isAuthenticated) return false;\n    \n    return roles.some(role => hasRole(role));\n  };\n\n  /**\n   * Check if user has any of the specified permissions.\n   */\n  const hasAnyPermission = (permissions: string[]): boolean => {\n    if (!state.user || !state.isAuthenticated) return false;\n    \n    return permissions.some(permission => hasPermission(permission));\n  };\n\n  /**\n   * Get all user permissions (direct + role-based).\n   */\n  const getUserPermissions = (): Permission[] => {\n    if (!state.user || !state.isAuthenticated) return [];\n    \n    const permissions = new Map<string, Permission>();\n    \n    // Add direct permissions\n    if (state.user.permissions) {\n      state.user.permissions.forEach(p => permissions.set(p.id, p));\n    }\n    \n    // Add role permissions\n    if (state.user.roles) {\n      state.user.roles.forEach(role => {\n        role.permissions.forEach(p => permissions.set(p.id, p));\n      });\n    }\n    \n    return Array.from(permissions.values());\n  };\n\n  /**\n   * Get all user roles.\n   */\n  const getUserRoles = (): Role[] => {\n    if (!state.user || !state.isAuthenticated) return [];\n    \n    return state.user.roles || [];\n  };\n\n  /**\n   * Check if user is admin (superuser or has admin role).\n   */\n  const isAdmin = (): boolean => {\n    if (!state.user || !state.isAuthenticated) return false;\n    \n    return state.user.is_superuser || hasRole('admin') || hasRole('organization_owner');\n  };\n\n  /**\n   * Check if user can access a resource with specific action.\n   */\n  const canAccess = (resource: string, action: string, organizationId?: string): boolean => {\n    if (!state.user || !state.isAuthenticated) return false;\n    \n    // Build permission name from resource and action\n    const permissionName = `${action}_${resource}`;\n    \n    return hasPermission(permissionName, organizationId);\n  };\n\n  const contextValue: AuthContextType = {\n    state,\n    login,\n    logout,\n    refreshToken,\n    getCurrentUser,\n    hasPermission,\n    hasRole,\n    hasAnyRole,\n    hasAnyPermission,\n    getUserPermissions,\n    getUserRoles,\n    isAdmin,\n    canAccess,\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n/**\n * Hook to access authentication context.\n * \n * @returns AuthContextType - Authentication state and methods\n * @throws Error if used outside AuthProvider\n */\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  \n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  \n  return context;\n};\n\nexport default AuthContext; "],"names":["AuthProvider","useAuth","initialState","isAuthenticated","isLoading","user","tokens","error","authReducer","state","action","type","payload","AuthContext","createContext","undefined","STORAGE_KEYS","ACCESS_TOKEN","REFRESH_TOKEN","USER_DATA","API_BASE_URL","process","env","NEXT_PUBLIC_API_BASE_URL","children","dispatch","useReducer","useEffect","initializeAuth","accessToken","localStorage","getItem","refreshToken","userData","JSON","parse","access_token","refresh_token","token_type","getCurrentUser","clearStoredAuth","removeItem","storeAuthData","setItem","stringify","authenticatedFetch","url","options","Error","response","fetch","headers","status","refreshError","logout","login","code","state_param","method","body","ok","json","detail","userResponse","message","console","warn","hasPermission","permission","organizationId","is_superuser","permissions","some","p","name","organization_id","roles","role","hasRole","r","hasAnyRole","hasAnyPermission","getUserPermissions","Map","forEach","set","id","Array","from","values","getUserRoles","isAdmin","canAccess","resource","permissionName","contextValue","Provider","value","context","useContext"],"mappings":"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"}