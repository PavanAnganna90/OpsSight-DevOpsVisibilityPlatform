{"version":3,"sources":["/Users/pavan/Desktop/Devops-app-dev-cursor/frontend/src/hooks/useWebSocket.ts"],"sourcesContent":["/**\n * WebSocket Hook for Real-time Pipeline Updates\n * \n * Custom React hook providing WebSocket connectivity with:\n * - Automatic connection management\n * - Reconnection with exponential backoff\n * - Connection status tracking\n * - Message handling for pipeline updates\n * - Cleanup on component unmount\n */\n\nimport { useEffect, useRef, useState, useCallback } from 'react';\n\nexport type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error';\n\nexport interface WebSocketMessage {\n  type: string;\n  payload: any;\n  timestamp: string;\n}\n\nexport interface PipelineUpdateMessage extends WebSocketMessage {\n  type: 'pipeline_update';\n  payload: {\n    pipeline_id: number;\n    run_id: number;\n    status: string;\n    progress?: number;\n    stage?: string;\n    job?: string;\n    step?: string;\n    duration?: number;\n    eta?: number;\n  };\n}\n\nexport interface UseWebSocketOptions {\n  /** WebSocket server URL */\n  url: string;\n  /** Protocols to use */\n  protocols?: string | string[];\n  /** Auto-connect on mount */\n  autoConnect?: boolean;\n  /** Reconnection attempts before giving up */\n  maxReconnectAttempts?: number;\n  /** Base delay for reconnection (ms) */\n  reconnectDelay?: number;\n  /** Maximum delay for reconnection (ms) */\n  maxReconnectDelay?: number;\n  /** Authentication token */\n  token?: string;\n}\n\nexport interface UseWebSocketReturn {\n  /** Current connection status */\n  connectionStatus: ConnectionStatus;\n  /** Send message to server */\n  sendMessage: (message: WebSocketMessage) => void;\n  /** Connect to WebSocket server */\n  connect: () => void;\n  /** Disconnect from WebSocket server */\n  disconnect: () => void;\n  /** Subscribe to specific message types */\n  subscribe: (messageType: string, callback: (message: WebSocketMessage) => void) => () => void;\n  /** Last error that occurred */\n  lastError: Error | null;\n  /** Whether currently attempting to reconnect */\n  isReconnecting: boolean;\n}\n\n/**\n * Custom hook for WebSocket connections with automatic reconnection\n */\nexport const useWebSocket = (options: UseWebSocketOptions): UseWebSocketReturn => {\n  const {\n    url,\n    protocols,\n    autoConnect = true,\n    maxReconnectAttempts = 10,\n    reconnectDelay = 1000,\n    maxReconnectDelay = 30000,\n    token\n  } = options;\n\n  // State\n  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>('disconnected');\n  const [lastError, setLastError] = useState<Error | null>(null);\n  const [isReconnecting, setIsReconnecting] = useState(false);\n\n  // Refs\n  const socketRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const reconnectAttemptsRef = useRef(0);\n  const subscribersRef = useRef<Map<string, Set<(message: WebSocketMessage) => void>>>(new Map());\n  const heartbeatIntervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  /**\n   * Clear reconnection timeout\n   */\n  const clearReconnectTimeout = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n  }, []);\n\n  /**\n   * Clear heartbeat interval\n   */\n  const clearHeartbeat = useCallback(() => {\n    if (heartbeatIntervalRef.current) {\n      clearInterval(heartbeatIntervalRef.current);\n      heartbeatIntervalRef.current = null;\n    }\n  }, []);\n\n  /**\n   * Start heartbeat to keep connection alive\n   */\n  const startHeartbeat = useCallback(() => {\n    clearHeartbeat();\n    heartbeatIntervalRef.current = setInterval(() => {\n      if (socketRef.current?.readyState === WebSocket.OPEN) {\n        socketRef.current.send(JSON.stringify({\n          type: 'ping',\n          payload: {},\n          timestamp: new Date().toISOString()\n        }));\n      }\n    }, 30000); // Send ping every 30 seconds\n  }, [clearHeartbeat]);\n\n  /**\n   * Handle incoming WebSocket messages\n   */\n  const handleMessage = useCallback((event: MessageEvent) => {\n    try {\n      const message: WebSocketMessage = JSON.parse(event.data);\n      \n      // Handle pong messages\n      if (message.type === 'pong') {\n        return;\n      }\n\n      // Dispatch to subscribers\n      const subscribers = subscribersRef.current.get(message.type);\n      if (subscribers) {\n        subscribers.forEach(callback => callback(message));\n      }\n\n      // Dispatch to wildcard subscribers\n      const wildcardSubscribers = subscribersRef.current.get('*');\n      if (wildcardSubscribers) {\n        wildcardSubscribers.forEach(callback => callback(message));\n      }\n    } catch (error) {\n      console.warn('Failed to parse WebSocket message:', error);\n    }\n  }, []);\n\n  /**\n   * Connect to WebSocket server\n   */\n  const connect = useCallback(() => {\n    if (socketRef.current?.readyState === WebSocket.OPEN) {\n      return; // Already connected\n    }\n\n    setConnectionStatus('connecting');\n    setLastError(null);\n\n    try {\n      // Construct WebSocket URL with token if provided\n      const wsUrl = token ? `${url}?token=${encodeURIComponent(token)}` : url;\n      \n      const socket = new WebSocket(wsUrl, protocols);\n      socketRef.current = socket;\n\n      socket.onopen = () => {\n        setConnectionStatus('connected');\n        setIsReconnecting(false);\n        reconnectAttemptsRef.current = 0;\n        clearReconnectTimeout();\n        startHeartbeat();\n        \n        // Send initial connection message\n        socket.send(JSON.stringify({\n          type: 'connect',\n          payload: { timestamp: new Date().toISOString() },\n          timestamp: new Date().toISOString()\n        }));\n      };\n\n      socket.onmessage = handleMessage;\n\n      socket.onclose = (event) => {\n        setConnectionStatus('disconnected');\n        clearHeartbeat();\n        \n        // Attempt reconnection if not intentionally closed\n        if (!event.wasClean && reconnectAttemptsRef.current < maxReconnectAttempts) {\n          setIsReconnecting(true);\n          const delay = Math.min(\n            reconnectDelay * Math.pow(2, reconnectAttemptsRef.current),\n            maxReconnectDelay\n          );\n          \n          reconnectTimeoutRef.current = setTimeout(() => {\n            reconnectAttemptsRef.current++;\n            connect();\n          }, delay);\n        } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n          setIsReconnecting(false);\n          setLastError(new Error('Maximum reconnection attempts reached'));\n        }\n      };\n\n      socket.onerror = (error) => {\n        setConnectionStatus('error');\n        setLastError(new Error('WebSocket connection error'));\n        clearHeartbeat();\n      };\n\n    } catch (error) {\n      setConnectionStatus('error');\n      setLastError(error as Error);\n    }\n  }, [url, protocols, token, maxReconnectAttempts, reconnectDelay, maxReconnectDelay, handleMessage, startHeartbeat, clearHeartbeat, clearReconnectTimeout]);\n\n  /**\n   * Disconnect from WebSocket server\n   */\n  const disconnect = useCallback(() => {\n    clearReconnectTimeout();\n    clearHeartbeat();\n    setIsReconnecting(false);\n    \n    if (socketRef.current) {\n      socketRef.current.close(1000, 'Manual disconnect');\n      socketRef.current = null;\n    }\n    \n    setConnectionStatus('disconnected');\n  }, [clearReconnectTimeout, clearHeartbeat]);\n\n  /**\n   * Send message to WebSocket server\n   */\n  const sendMessage = useCallback((message: WebSocketMessage) => {\n    if (socketRef.current?.readyState === WebSocket.OPEN) {\n      try {\n        socketRef.current.send(JSON.stringify({\n          ...message,\n          timestamp: message.timestamp || new Date().toISOString()\n        }));\n      } catch (error) {\n        console.error('Failed to send WebSocket message:', error);\n        setLastError(error as Error);\n      }\n    } else {\n      console.warn('WebSocket is not connected. Cannot send message.');\n    }\n  }, []);\n\n  /**\n   * Subscribe to specific message types\n   */\n  const subscribe = useCallback((messageType: string, callback: (message: WebSocketMessage) => void) => {\n    if (!subscribersRef.current.has(messageType)) {\n      subscribersRef.current.set(messageType, new Set());\n    }\n    \n    subscribersRef.current.get(messageType)!.add(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      const subscribers = subscribersRef.current.get(messageType);\n      if (subscribers) {\n        subscribers.delete(callback);\n        if (subscribers.size === 0) {\n          subscribersRef.current.delete(messageType);\n        }\n      }\n    };\n  }, []);\n\n  // Auto-connect on mount if enabled\n  useEffect(() => {\n    if (autoConnect) {\n      connect();\n    }\n\n    // Cleanup on unmount\n    return () => {\n      disconnect();\n    };\n  }, [autoConnect, connect, disconnect]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      clearReconnectTimeout();\n      clearHeartbeat();\n    };\n  }, [clearReconnectTimeout, clearHeartbeat]);\n\n  return {\n    connectionStatus,\n    sendMessage,\n    connect,\n    disconnect,\n    subscribe,\n    lastError,\n    isReconnecting\n  };\n};\n\nexport default useWebSocket; "],"names":["useWebSocket","options","url","protocols","autoConnect","maxReconnectAttempts","reconnectDelay","maxReconnectDelay","token","connectionStatus","setConnectionStatus","useState","lastError","setLastError","isReconnecting","setIsReconnecting","socketRef","useRef","reconnectTimeoutRef","reconnectAttemptsRef","subscribersRef","Map","heartbeatIntervalRef","clearReconnectTimeout","useCallback","current","clearTimeout","clearHeartbeat","clearInterval","startHeartbeat","setInterval","readyState","WebSocket","OPEN","send","JSON","stringify","type","payload","timestamp","Date","toISOString","handleMessage","event","message","parse","data","subscribers","get","forEach","callback","wildcardSubscribers","error","console","warn","connect","wsUrl","encodeURIComponent","socket","onopen","onmessage","onclose","wasClean","delay","Math","min","pow","setTimeout","Error","onerror","disconnect","close","sendMessage","subscribe","messageType","has","set","Set","add","delete","size","useEffect"],"mappings":"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"}