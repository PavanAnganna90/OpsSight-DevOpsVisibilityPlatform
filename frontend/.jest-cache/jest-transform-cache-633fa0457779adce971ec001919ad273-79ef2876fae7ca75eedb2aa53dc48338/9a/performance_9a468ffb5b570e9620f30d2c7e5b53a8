ea43515e7b976a561fee33f3c1c81677
/**
 * Performance Utilities for React 19 and Next.js 15
 * Comprehensive performance optimization utilities
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    lazyImport: function() {
        return lazyImport;
    },
    measurePerformance: function() {
        return measurePerformance;
    },
    prefetchDNS: function() {
        return prefetchDNS;
    },
    preloadResource: function() {
        return preloadResource;
    },
    useAnimationFrame: function() {
        return useAnimationFrame;
    },
    useDebounce: function() {
        return useDebounce;
    },
    useDebounced: function() {
        return useDebounced;
    },
    useDeepMemo: function() {
        return useDeepMemo;
    },
    useIntersectionObserver: function() {
        return useIntersectionObserver;
    },
    useLazyImage: function() {
        return useLazyImage;
    },
    useMemoryMonitor: function() {
        return useMemoryMonitor;
    },
    useOptimizedForm: function() {
        return useOptimizedForm;
    },
    usePerformanceBudget: function() {
        return usePerformanceBudget;
    },
    usePerformanceMonitor: function() {
        return usePerformanceMonitor;
    },
    useProfiledCallback: function() {
        return useProfiledCallback;
    },
    useProfiledMemo: function() {
        return useProfiledMemo;
    },
    useProgressiveImage: function() {
        return useProgressiveImage;
    },
    useStableCallback: function() {
        return useStableCallback;
    },
    useThrottle: function() {
        return useThrottle;
    },
    useThrottled: function() {
        return useThrottled;
    },
    useVirtualScroll: function() {
        return useVirtualScroll;
    },
    useVirtualScrolling: function() {
        return useVirtualScrolling;
    },
    withSuspense: function() {
        return withSuspense;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function useProfiledMemo(factory, deps, debugLabel) {
    return (0, _react.useMemo)(()=>{
        if (process.env.NODE_ENV === 'development' && debugLabel) {
            const start = performance.now();
            const result = factory();
            const end = performance.now();
            if (end - start > 1) {
                console.warn(`[Performance] ${debugLabel} took ${(end - start).toFixed(2)}ms`);
            }
            return result;
        }
        return factory();
    }, deps);
}
function useProfiledCallback(callback, deps, debugLabel) {
    return (0, _react.useCallback)((...args)=>{
        if (process.env.NODE_ENV === 'development' && debugLabel) {
            const start = performance.now();
            const result = callback(...args);
            const end = performance.now();
            if (end - start > 1) {
                console.warn(`[Performance] ${debugLabel} execution took ${(end - start).toFixed(2)}ms`);
            }
            return result;
        }
        return callback(...args);
    }, deps);
}
function useDebounced(value, delay) {
    const [debouncedValue, setDebouncedValue] = (0, _react.useState)(value);
    (0, _react.useEffect)(()=>{
        const handler = setTimeout(()=>{
            setDebouncedValue(value);
        }, delay);
        return ()=>{
            clearTimeout(handler);
        };
    }, [
        value,
        delay
    ]);
    return debouncedValue;
}
const useDebounce = useDebounced;
function useThrottled(callback, delay) {
    const lastCall = (0, _react.useRef)(0);
    return (0, _react.useCallback)((...args)=>{
        const now = Date.now();
        if (now - lastCall.current >= delay) {
            lastCall.current = now;
            return callback(...args);
        }
    }, [
        callback,
        delay
    ]);
}
const useThrottle = useThrottled;
function useIntersectionObserver(config = {}) {
    const { threshold = 0, rootMargin = '0px', root = null } = config;
    const ref = (0, _react.useRef)(null);
    const [isIntersecting, setIsIntersecting] = (0, _react.useState)(false);
    const [entry, setEntry] = (0, _react.useState)(null);
    (0, _react.useEffect)(()=>{
        const element = ref.current;
        if (!element) return;
        const observer = new IntersectionObserver(([entry])=>{
            setIsIntersecting(entry.isIntersecting);
            setEntry(entry);
        }, {
            threshold,
            rootMargin,
            root
        });
        observer.observe(element);
        return ()=>{
            observer.disconnect();
        };
    }, [
        threshold,
        rootMargin,
        root
    ]);
    return {
        ref,
        isIntersecting,
        entry
    };
}
function useVirtualScroll(items, config) {
    const { itemHeight, containerHeight, overscan = 3 } = config;
    const [scrollTop, setScrollTop] = (0, _react.useState)(0);
    const visibleRange = (0, _react.useMemo)(()=>{
        const start = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);
        const end = Math.min(items.length, Math.ceil((scrollTop + containerHeight) / itemHeight) + overscan);
        return {
            start,
            end
        };
    }, [
        scrollTop,
        itemHeight,
        containerHeight,
        overscan,
        items.length
    ]);
    const totalHeight = items.length * itemHeight;
    const offsetY = visibleRange.start * itemHeight;
    (0, _react.useEffect)(()=>{
        const handleScroll = (e)=>{
            const target = e.target;
            setScrollTop(target.scrollTop);
        };
        const scrollContainer = document.getElementById('virtual-scroll-container');
        scrollContainer?.addEventListener('scroll', handleScroll);
        return ()=>{
            scrollContainer?.removeEventListener('scroll', handleScroll);
        };
    }, []);
    return {
        visibleRange,
        totalHeight,
        offsetY
    };
}
function useVirtualScrolling({ items, itemHeight, containerHeight, overscan = 5 }) {
    const [scrollTop, setScrollTop] = (0, _react.useState)(0);
    const visibleRange = (0, _react.useMemo)(()=>{
        const start = Math.floor(scrollTop / itemHeight);
        const end = Math.min(start + Math.ceil(containerHeight / itemHeight) + overscan, items.length);
        return {
            start: Math.max(0, start - overscan),
            end
        };
    }, [
        scrollTop,
        itemHeight,
        containerHeight,
        overscan,
        items.length
    ]);
    const visibleItems = (0, _react.useMemo)(()=>{
        return items.slice(visibleRange.start, visibleRange.end).map((item, index)=>({
                item,
                index: visibleRange.start + index,
                style: {
                    position: 'absolute',
                    top: (visibleRange.start + index) * itemHeight,
                    height: itemHeight,
                    width: '100%'
                }
            }));
    }, [
        items,
        visibleRange,
        itemHeight
    ]);
    const totalHeight = items.length * itemHeight;
    const handleScroll = (0, _react.useCallback)((event)=>{
        setScrollTop(event.currentTarget.scrollTop);
    }, []);
    return {
        visibleItems,
        totalHeight,
        handleScroll
    };
}
function usePerformanceMonitor(componentName) {
    const renderStart = (0, _react.useRef)(performance.now());
    const renderCount = (0, _react.useRef)(0);
    (0, _react.useEffect)(()=>{
        renderCount.current += 1;
        const renderTime = performance.now() - renderStart.current;
        if (process.env.NODE_ENV === 'development') {
            console.log(`[Performance] ${componentName} render #${renderCount.current} took ${renderTime.toFixed(2)}ms`);
            // Warn about slow renders
            if (renderTime > 16) {
                console.warn(`[Performance] ${componentName} render exceeded 16ms budget (${renderTime.toFixed(2)}ms)`);
            }
        }
        renderStart.current = performance.now();
    });
    return {
        renderCount: renderCount.current
    };
}
function useMemoryMonitor(componentName) {
    (0, _react.useEffect)(()=>{
        if (process.env.NODE_ENV === 'development' && 'memory' in performance) {
            const memory = performance.memory;
            console.log(`[Memory] ${componentName} - Used: ${Math.round(memory.usedJSHeapSize / 1024 / 1024)}MB`);
        }
    });
}
function useStableCallback(callback) {
    const callbackRef = (0, _react.useRef)(callback);
    (0, _react.useEffect)(()=>{
        callbackRef.current = callback;
    });
    return (0, _react.useCallback)((...args)=>{
        return callbackRef.current(...args);
    }, []);
}
/**
 * Deep equality comparison function
 * @param a - First value to compare
 * @param b - Second value to compare
 * @returns True if values are deeply equal
 */ function deepEqual(a, b) {
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (typeof a !== 'object' || typeof b !== 'object') return false;
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) return false;
    for (const key of keysA){
        if (!keysB.includes(key)) return false;
        if (!deepEqual(a[key], b[key])) return false;
    }
    return true;
}
function useDeepMemo(factory, deps) {
    const ref = (0, _react.useRef)();
    if (!ref.current || !deepEqual(ref.current.deps, deps)) {
        ref.current = {
            value: factory(),
            deps
        };
    }
    return ref.current.value;
}
function useLazyImage(config) {
    const { src, placeholder = '', threshold = 0, rootMargin = '50px' } = config;
    const [imageSrc, setImageSrc] = (0, _react.useState)(placeholder);
    const [isLoaded, setIsLoaded] = (0, _react.useState)(false);
    const [isError, setIsError] = (0, _react.useState)(false);
    const { ref, isIntersecting } = useIntersectionObserver({
        threshold,
        rootMargin
    });
    (0, _react.useEffect)(()=>{
        if (!isIntersecting || isLoaded) return;
        const img = new Image();
        img.onload = ()=>{
            setImageSrc(src);
            setIsLoaded(true);
            setIsError(false);
        };
        img.onerror = ()=>{
            setIsError(true);
            setIsLoaded(true);
        };
        img.src = src;
    }, [
        src,
        isIntersecting,
        isLoaded
    ]);
    return {
        ref,
        imageSrc,
        isLoaded,
        isError
    };
}
function useProgressiveImage(src, placeholderSrc) {
    const [currentSrc, setCurrentSrc] = (0, _react.useState)(placeholderSrc || src);
    const [isLoading, setIsLoading] = (0, _react.useState)(true);
    const [isError, setIsError] = (0, _react.useState)(false);
    (0, _react.useEffect)(()=>{
        const img = new Image();
        img.onload = ()=>{
            setCurrentSrc(src);
            setIsLoading(false);
        };
        img.onerror = ()=>{
            setIsError(true);
            setIsLoading(false);
        };
        img.src = src;
        return ()=>{
            img.onload = null;
            img.onerror = null;
        };
    }, [
        src
    ]);
    return {
        src: currentSrc,
        isLoading,
        isError
    };
}
function useAnimationFrame(callback, deps) {
    const requestRef = (0, _react.useRef)();
    (0, _react.useEffect)(()=>{
        const animate = ()=>{
            callback();
            requestRef.current = requestAnimationFrame(animate);
        };
        requestRef.current = requestAnimationFrame(animate);
        return ()=>{
            if (requestRef.current) {
                cancelAnimationFrame(requestRef.current);
            }
        };
    }, deps);
}
const lazyImport = (importFn, namedExport)=>{
    return (0, _react.lazy)(()=>importFn().then((module)=>({
                default: namedExport ? module[namedExport] : module.default || module
            })));
};
function preloadResource(href, as) {
    if (typeof window === 'undefined') return;
    const link = document.createElement('link');
    link.rel = 'preload';
    link.href = href;
    link.as = as;
    document.head.appendChild(link);
}
function prefetchDNS(domain) {
    if (typeof window === 'undefined') return;
    const link = document.createElement('link');
    link.rel = 'dns-prefetch';
    link.href = domain;
    document.head.appendChild(link);
}
const withSuspense = (Component, fallback = _react.default.createElement('div', {}, 'Loading...'))=>{
    return (props)=>_react.default.createElement(_react.Suspense, {
            fallback
        }, _react.default.createElement(Component, props));
};
function useOptimizedForm(initialValues, onSubmit) {
    const [values, setValues] = (0, _react.useState)(initialValues);
    const [isSubmitting, setIsSubmitting] = (0, _react.useState)(false);
    const handleChange = (0, _react.useCallback)((name, value)=>{
        (0, _react.startTransition)(()=>{
            setValues((prev)=>({
                    ...prev,
                    [name]: value
                }));
        });
    }, []);
    const handleSubmit = (0, _react.useCallback)(async (event)=>{
        event.preventDefault();
        try {
            setIsSubmitting(true);
            await onSubmit(values);
        } finally{
            setIsSubmitting(false);
        }
    }, [
        values,
        onSubmit
    ]);
    const reset = (0, _react.useCallback)(()=>{
        (0, _react.startTransition)(()=>{
            setValues(initialValues);
        });
    }, [
        initialValues
    ]);
    return {
        values,
        handleChange,
        handleSubmit,
        reset,
        isSubmitting
    };
}
function usePerformanceBudget() {
    (0, _react.useEffect)(()=>{
        if (typeof window === 'undefined' || process.env.NODE_ENV !== 'development') return;
        const observer = new PerformanceObserver((list)=>{
            for (const entry of list.getEntries()){
                if (entry.entryType === 'measure') {
                    const duration = entry.duration;
                    if (duration > 100) {
                        console.warn(`[Performance Budget] ${entry.name} exceeded 100ms budget: ${duration.toFixed(2)}ms`);
                    }
                }
            }
        });
        observer.observe({
            entryTypes: [
                'measure'
            ]
        });
        return ()=>{
            observer.disconnect();
        };
    }, []);
}
const measurePerformance = {
    start: (name)=>{
        if (typeof window !== 'undefined') {
            performance.mark(`${name}-start`);
        }
    },
    end: (name)=>{
        if (typeof window !== 'undefined') {
            performance.mark(`${name}-end`);
            performance.measure(name, `${name}-start`, `${name}-end`);
        }
    },
    clear: (name)=>{
        if (typeof window !== 'undefined') {
            performance.clearMarks(`${name}-start`);
            performance.clearMarks(`${name}-end`);
            performance.clearMeasures(name);
        }
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXZhbi9EZXNrdG9wL0Rldm9wcy1hcHAtZGV2LWN1cnNvci9mcm9udGVuZC9zcmMvdXRpbHMvcGVyZm9ybWFuY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQZXJmb3JtYW5jZSBVdGlsaXRpZXMgZm9yIFJlYWN0IDE5IGFuZCBOZXh0LmpzIDE1XG4gKiBDb21wcmVoZW5zaXZlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB1dGlsaXRpZXNcbiAqL1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZVJlZiwgdXNlRWZmZWN0LCBzdGFydFRyYW5zaXRpb24sIHVzZVN0YXRlLCBTdXNwZW5zZSwgbGF6eSwgRGVwZW5kZW5jeUxpc3QgfSBmcm9tICdyZWFjdCc7XG5cbi8vIFJlYWN0IDE5IFBlcmZvcm1hbmNlIEZlYXR1cmVzIChjb21tZW50ZWQgb3V0IHVudGlsIFJlYWN0IDE5IGlzIHN0YWJsZSlcbi8vIGV4cG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiwgdXNlT3B0aW1pc3RpYywgdXNlRm9ybVN0YXR1cywgdXNlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEVuaGFuY2VkIHVzZU1lbW8gd2l0aCBwZXJmb3JtYW5jZSBwcm9maWxpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVByb2ZpbGVkTWVtbzxUPihcbiAgZmFjdG9yeTogKCkgPT4gVCxcbiAgZGVwczogUmVhY3QuRGVwZW5kZW5jeUxpc3QgfCB1bmRlZmluZWQsXG4gIGRlYnVnTGFiZWw/OiBzdHJpbmdcbik6IFQge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGRlYnVnTGFiZWwpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBmYWN0b3J5KCk7XG4gICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgaWYgKGVuZCAtIHN0YXJ0ID4gMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtQZXJmb3JtYW5jZV0gJHtkZWJ1Z0xhYmVsfSB0b29rICR7KGVuZCAtIHN0YXJ0KS50b0ZpeGVkKDIpfW1zYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWN0b3J5KCk7XG4gIH0sIGRlcHMpO1xufVxuXG4vKipcbiAqIEVuaGFuY2VkIHVzZUNhbGxiYWNrIHdpdGggcGVyZm9ybWFuY2UgcHJvZmlsaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQcm9maWxlZENhbGxiYWNrPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG4gIGNhbGxiYWNrOiBULFxuICBkZXBzOiBSZWFjdC5EZXBlbmRlbmN5TGlzdCxcbiAgZGVidWdMYWJlbD86IHN0cmluZ1xuKTogVCB7XG4gIHJldHVybiB1c2VDYWxsYmFjaygoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBkZWJ1Z0xhYmVsKSB7XG4gICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soLi4uYXJncyk7XG4gICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgaWYgKGVuZCAtIHN0YXJ0ID4gMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtQZXJmb3JtYW5jZV0gJHtkZWJ1Z0xhYmVsfSBleGVjdXRpb24gdG9vayAkeyhlbmQgLSBzdGFydCkudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gY2FsbGJhY2soLi4uYXJncyk7XG4gIH0sIGRlcHMpIGFzIFQ7XG59XG5cbi8qKlxuICogRGVib3VuY2VkIHZhbHVlIGhvb2sgZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVib3VuY2VkPFQ+KHZhbHVlOiBULCBkZWxheTogbnVtYmVyKTogVCB7XG4gIGNvbnN0IFtkZWJvdW5jZWRWYWx1ZSwgc2V0RGVib3VuY2VkVmFsdWVdID0gdXNlU3RhdGU8VD4odmFsdWUpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0RGVib3VuY2VkVmFsdWUodmFsdWUpO1xuICAgIH0sIGRlbGF5KTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoaGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW3ZhbHVlLCBkZWxheV0pO1xuXG4gIHJldHVybiBkZWJvdW5jZWRWYWx1ZTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3IgdXNlRGVib3VuY2VkIHRvIG1hdGNoIHJlcXVlc3RlZCBBUElcbiAqL1xuZXhwb3J0IGNvbnN0IHVzZURlYm91bmNlID0gdXNlRGVib3VuY2VkO1xuXG4vKipcbiAqIFRocm90dGxlZCBjYWxsYmFjayBob29rXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VUaHJvdHRsZWQ8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbiAgY2FsbGJhY2s6IFQsXG4gIGRlbGF5OiBudW1iZXJcbik6IFQge1xuICBjb25zdCBsYXN0Q2FsbCA9IHVzZVJlZjxudW1iZXI+KDApO1xuICBcbiAgcmV0dXJuIHVzZUNhbGxiYWNrKCguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICBpZiAobm93IC0gbGFzdENhbGwuY3VycmVudCA+PSBkZWxheSkge1xuICAgICAgbGFzdENhbGwuY3VycmVudCA9IG5vdztcbiAgICAgIHJldHVybiBjYWxsYmFjayguLi5hcmdzKTtcbiAgICB9XG4gIH0sIFtjYWxsYmFjaywgZGVsYXldKSBhcyBUO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB1c2VUaHJvdHRsZWQgdG8gbWF0Y2ggcmVxdWVzdGVkIEFQSVxuICovXG5leHBvcnQgY29uc3QgdXNlVGhyb3R0bGUgPSB1c2VUaHJvdHRsZWQ7XG5cbi8qKlxuICogSW50ZXJzZWN0aW9uIG9ic2VydmVyIGNvbmZpZ3VyYXRpb25cbiAqL1xuaW50ZXJmYWNlIEludGVyc2VjdGlvbk9ic2VydmVyQ29uZmlnIHtcbiAgdGhyZXNob2xkPzogbnVtYmVyIHwgbnVtYmVyW107XG4gIHJvb3RNYXJnaW4/OiBzdHJpbmc7XG4gIHJvb3Q/OiBFbGVtZW50IHwgbnVsbDtcbn1cblxuLyoqXG4gKiBFbmhhbmNlZCBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXIgaG9va1xuICogQHBhcmFtIGNvbmZpZyAtIEludGVyc2VjdGlvbiBvYnNlcnZlciBjb25maWd1cmF0aW9uXG4gKiBAcmV0dXJucyBSZWYgdG8gYXR0YWNoIHRvIGVsZW1lbnQgYW5kIGludGVyc2VjdGlvbiBzdGF0ZVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHsgcmVmLCBpc0ludGVyc2VjdGluZyB9ID0gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoeyB0aHJlc2hvbGQ6IDAuNSB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbk9ic2VydmVyPFQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oXG4gIGNvbmZpZzogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDb25maWcgPSB7fVxuKToge1xuICByZWY6IFJlYWN0LlJlZk9iamVjdDxUPjtcbiAgaXNJbnRlcnNlY3Rpbmc6IGJvb2xlYW47XG4gIGVudHJ5OiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5IHwgbnVsbDtcbn0ge1xuICBjb25zdCB7IHRocmVzaG9sZCA9IDAsIHJvb3RNYXJnaW4gPSAnMHB4Jywgcm9vdCA9IG51bGwgfSA9IGNvbmZpZztcbiAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KG51bGwpO1xuICBjb25zdCBbaXNJbnRlcnNlY3RpbmcsIHNldElzSW50ZXJzZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2VudHJ5LCBzZXRFbnRyeV0gPSB1c2VTdGF0ZTxJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5IHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG5cbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAgIChbZW50cnldKSA9PiB7XG4gICAgICAgIHNldElzSW50ZXJzZWN0aW5nKGVudHJ5LmlzSW50ZXJzZWN0aW5nKTtcbiAgICAgICAgc2V0RW50cnkoZW50cnkpO1xuICAgICAgfSxcbiAgICAgIHsgdGhyZXNob2xkLCByb290TWFyZ2luLCByb290IH1cbiAgICApO1xuXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgfSwgW3RocmVzaG9sZCwgcm9vdE1hcmdpbiwgcm9vdF0pO1xuXG4gIHJldHVybiB7IHJlZiwgaXNJbnRlcnNlY3RpbmcsIGVudHJ5IH07XG59XG5cbi8qKlxuICogVmlydHVhbCBzY3JvbGwgY29uZmlndXJhdGlvblxuICovXG5pbnRlcmZhY2UgVmlydHVhbFNjcm9sbENvbmZpZyB7XG4gIGl0ZW1IZWlnaHQ6IG51bWJlcjtcbiAgY29udGFpbmVySGVpZ2h0OiBudW1iZXI7XG4gIG92ZXJzY2FuPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIFZpcnR1YWwgc2Nyb2xsIHJldHVybiB0eXBlXG4gKi9cbmludGVyZmFjZSBWaXJ0dWFsU2Nyb2xsUmV0dXJuIHtcbiAgdmlzaWJsZVJhbmdlOiB7IHN0YXJ0OiBudW1iZXI7IGVuZDogbnVtYmVyIH07XG4gIHRvdGFsSGVpZ2h0OiBudW1iZXI7XG4gIG9mZnNldFk6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayBmb3IgdmlydHVhbCBzY3JvbGxpbmcgbGFyZ2UgbGlzdHNcbiAqIEBwYXJhbSBpdGVtcyAtIEFycmF5IG9mIGl0ZW1zIHRvIHJlbmRlclxuICogQHBhcmFtIGNvbmZpZyAtIFZpcnR1YWwgc2Nyb2xsIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIFZpcnR1YWwgc2Nyb2xsIHByb3BlcnRpZXNcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB7IHZpc2libGVSYW5nZSwgdG90YWxIZWlnaHQsIG9mZnNldFkgfSA9IHVzZVZpcnR1YWxTY3JvbGwoaXRlbXMsIHtcbiAqICAgaXRlbUhlaWdodDogNTAsXG4gKiAgIGNvbnRhaW5lckhlaWdodDogNTAwLFxuICogICBvdmVyc2NhbjogNVxuICogfSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VWaXJ0dWFsU2Nyb2xsPFQ+KFxuICBpdGVtczogVFtdLFxuICBjb25maWc6IFZpcnR1YWxTY3JvbGxDb25maWdcbik6IFZpcnR1YWxTY3JvbGxSZXR1cm4ge1xuICBjb25zdCB7IGl0ZW1IZWlnaHQsIGNvbnRhaW5lckhlaWdodCwgb3ZlcnNjYW4gPSAzIH0gPSBjb25maWc7XG4gIGNvbnN0IFtzY3JvbGxUb3AsIHNldFNjcm9sbFRvcF0gPSB1c2VTdGF0ZSgwKTtcbiAgXG4gIGNvbnN0IHZpc2libGVSYW5nZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihzY3JvbGxUb3AgLyBpdGVtSGVpZ2h0KSAtIG92ZXJzY2FuKTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihcbiAgICAgIGl0ZW1zLmxlbmd0aCxcbiAgICAgIE1hdGguY2VpbCgoc2Nyb2xsVG9wICsgY29udGFpbmVySGVpZ2h0KSAvIGl0ZW1IZWlnaHQpICsgb3ZlcnNjYW5cbiAgICApO1xuICAgIFxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgfSwgW3Njcm9sbFRvcCwgaXRlbUhlaWdodCwgY29udGFpbmVySGVpZ2h0LCBvdmVyc2NhbiwgaXRlbXMubGVuZ3RoXSk7XG4gIFxuICBjb25zdCB0b3RhbEhlaWdodCA9IGl0ZW1zLmxlbmd0aCAqIGl0ZW1IZWlnaHQ7XG4gIGNvbnN0IG9mZnNldFkgPSB2aXNpYmxlUmFuZ2Uuc3RhcnQgKiBpdGVtSGVpZ2h0O1xuICBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTY3JvbGwgPSAoZTogRXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgc2V0U2Nyb2xsVG9wKHRhcmdldC5zY3JvbGxUb3ApO1xuICAgIH07XG4gICAgXG4gICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZpcnR1YWwtc2Nyb2xsLWNvbnRhaW5lcicpO1xuICAgIHNjcm9sbENvbnRhaW5lcj8uYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2Nyb2xsQ29udGFpbmVyPy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgXG4gIHJldHVybiB7IHZpc2libGVSYW5nZSwgdG90YWxIZWlnaHQsIG9mZnNldFkgfTtcbn1cblxuLyoqXG4gKiBMZWdhY3kgYWxpYXMgZm9yIGV4aXN0aW5nIGltcGxlbWVudGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VWaXJ0dWFsU2Nyb2xsaW5nPFQ+KHtcbiAgaXRlbXMsXG4gIGl0ZW1IZWlnaHQsXG4gIGNvbnRhaW5lckhlaWdodCxcbiAgb3ZlcnNjYW4gPSA1LFxufToge1xuICBpdGVtczogVFtdO1xuICBpdGVtSGVpZ2h0OiBudW1iZXI7XG4gIGNvbnRhaW5lckhlaWdodDogbnVtYmVyO1xuICBvdmVyc2Nhbj86IG51bWJlcjtcbn0pIHtcbiAgY29uc3QgW3Njcm9sbFRvcCwgc2V0U2Nyb2xsVG9wXSA9IHVzZVN0YXRlKDApO1xuICBcbiAgY29uc3QgdmlzaWJsZVJhbmdlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKHNjcm9sbFRvcCAvIGl0ZW1IZWlnaHQpO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKFxuICAgICAgc3RhcnQgKyBNYXRoLmNlaWwoY29udGFpbmVySGVpZ2h0IC8gaXRlbUhlaWdodCkgKyBvdmVyc2NhbixcbiAgICAgIGl0ZW1zLmxlbmd0aFxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBNYXRoLm1heCgwLCBzdGFydCAtIG92ZXJzY2FuKSxcbiAgICAgIGVuZCxcbiAgICB9O1xuICB9LCBbc2Nyb2xsVG9wLCBpdGVtSGVpZ2h0LCBjb250YWluZXJIZWlnaHQsIG92ZXJzY2FuLCBpdGVtcy5sZW5ndGhdKTtcblxuICBjb25zdCB2aXNpYmxlSXRlbXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gaXRlbXMuc2xpY2UodmlzaWJsZVJhbmdlLnN0YXJ0LCB2aXNpYmxlUmFuZ2UuZW5kKS5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoe1xuICAgICAgaXRlbSxcbiAgICAgIGluZGV4OiB2aXNpYmxlUmFuZ2Uuc3RhcnQgKyBpbmRleCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnIGFzIGNvbnN0LFxuICAgICAgICB0b3A6ICh2aXNpYmxlUmFuZ2Uuc3RhcnQgKyBpbmRleCkgKiBpdGVtSGVpZ2h0LFxuICAgICAgICBoZWlnaHQ6IGl0ZW1IZWlnaHQsXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICB9LFxuICAgIH0pKTtcbiAgfSwgW2l0ZW1zLCB2aXNpYmxlUmFuZ2UsIGl0ZW1IZWlnaHRdKTtcblxuICBjb25zdCB0b3RhbEhlaWdodCA9IGl0ZW1zLmxlbmd0aCAqIGl0ZW1IZWlnaHQ7XG5cbiAgY29uc3QgaGFuZGxlU2Nyb2xsID0gdXNlQ2FsbGJhY2soKGV2ZW50OiBSZWFjdC5VSUV2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIHNldFNjcm9sbFRvcChldmVudC5jdXJyZW50VGFyZ2V0LnNjcm9sbFRvcCk7XG4gIH0sIFtdKTtcblxuICByZXR1cm4ge1xuICAgIHZpc2libGVJdGVtcyxcbiAgICB0b3RhbEhlaWdodCxcbiAgICBoYW5kbGVTY3JvbGwsXG4gIH07XG59XG5cbi8qKlxuICogUGVyZm9ybWFuY2UgbW9uaXRvcmluZyBob29rXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQZXJmb3JtYW5jZU1vbml0b3IoY29tcG9uZW50TmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IHJlbmRlclN0YXJ0ID0gdXNlUmVmPG51bWJlcj4ocGVyZm9ybWFuY2Uubm93KCkpO1xuICBjb25zdCByZW5kZXJDb3VudCA9IHVzZVJlZjxudW1iZXI+KDApO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVuZGVyQ291bnQuY3VycmVudCArPSAxO1xuICAgIGNvbnN0IHJlbmRlclRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHJlbmRlclN0YXJ0LmN1cnJlbnQ7XG4gICAgXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW1BlcmZvcm1hbmNlXSAke2NvbXBvbmVudE5hbWV9IHJlbmRlciAjJHtyZW5kZXJDb3VudC5jdXJyZW50fSB0b29rICR7cmVuZGVyVGltZS50b0ZpeGVkKDIpfW1zYCk7XG4gICAgICBcbiAgICAgIC8vIFdhcm4gYWJvdXQgc2xvdyByZW5kZXJzXG4gICAgICBpZiAocmVuZGVyVGltZSA+IDE2KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW1BlcmZvcm1hbmNlXSAke2NvbXBvbmVudE5hbWV9IHJlbmRlciBleGNlZWRlZCAxNm1zIGJ1ZGdldCAoJHtyZW5kZXJUaW1lLnRvRml4ZWQoMil9bXMpYCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJlbmRlclN0YXJ0LmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICByZW5kZXJDb3VudDogcmVuZGVyQ291bnQuY3VycmVudCxcbiAgfTtcbn1cblxuLyoqXG4gKiBNZW1vcnkgdXNhZ2UgbW9uaXRvcmluZyBob29rXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW1vcnlNb25pdG9yKGNvbXBvbmVudE5hbWU6IHN0cmluZykge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnbWVtb3J5JyBpbiBwZXJmb3JtYW5jZSkge1xuICAgICAgY29uc3QgbWVtb3J5ID0gKHBlcmZvcm1hbmNlIGFzIGFueSkubWVtb3J5O1xuICAgICAgY29uc29sZS5sb2coYFtNZW1vcnldICR7Y29tcG9uZW50TmFtZX0gLSBVc2VkOiAke01hdGgucm91bmQobWVtb3J5LnVzZWRKU0hlYXBTaXplIC8gMTAyNCAvIDEwMjQpfU1CYCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayB0aGF0IHJldHVybnMgYSBzdGFibGUgY2FsbGJhY2sgcmVmZXJlbmNlXG4gKiBQcmV2ZW50cyB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzIHdoZW4gY2FsbGJhY2sgZGVwZW5kZW5jaWVzIGNoYW5nZVxuICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyBBIHN0YWJsZSBjYWxsYmFjayByZWZlcmVuY2VcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjazxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuICBjYWxsYmFjazogVFxuKTogVCB7XG4gIGNvbnN0IGNhbGxiYWNrUmVmID0gdXNlUmVmPFQ+KGNhbGxiYWNrKTtcbiAgXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tSZWYuY3VycmVudCA9IGNhbGxiYWNrO1xuICB9KTtcblxuICByZXR1cm4gdXNlQ2FsbGJhY2soXG4gICAgKCguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2tSZWYuY3VycmVudCguLi5hcmdzKTtcbiAgICB9KSBhcyBULFxuICAgIFtdXG4gICk7XG59XG5cbi8qKlxuICogRGVlcCBlcXVhbGl0eSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gYSAtIEZpcnN0IHZhbHVlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBiIC0gU2Vjb25kIHZhbHVlIHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIFRydWUgaWYgdmFsdWVzIGFyZSBkZWVwbHkgZXF1YWxcbiAqL1xuZnVuY3Rpb24gZGVlcEVxdWFsKGE6IGFueSwgYjogYW55KTogYm9vbGVhbiB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIFxuICBpZiAodHlwZW9mIGEgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICBcbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5c0EpIHtcbiAgICBpZiAoIWtleXNCLmluY2x1ZGVzKGtleSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ3VzdG9tIGhvb2sgdGhhdCBtZW1vaXplcyBhIHZhbHVlIHdpdGggZGVlcCBlcXVhbGl0eSBjb21wYXJpc29uXG4gKiBAcGFyYW0gZmFjdG9yeSAtIEZhY3RvcnkgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB2YWx1ZVxuICogQHBhcmFtIGRlcHMgLSBEZXBlbmRlbmNpZXMgYXJyYXlcbiAqIEByZXR1cm5zIFRoZSBtZW1vaXplZCB2YWx1ZVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGNvbXBsZXhPYmplY3QgPSB1c2VEZWVwTWVtbygoKSA9PiAoeyAuLi5kYXRhIH0pLCBbZGF0YV0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVlcE1lbW88VD4oXG4gIGZhY3Rvcnk6ICgpID0+IFQsXG4gIGRlcHM6IERlcGVuZGVuY3lMaXN0XG4pOiBUIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmPHsgdmFsdWU6IFQ7IGRlcHM6IERlcGVuZGVuY3lMaXN0IH0+KCk7XG5cbiAgaWYgKCFyZWYuY3VycmVudCB8fCAhZGVlcEVxdWFsKHJlZi5jdXJyZW50LmRlcHMsIGRlcHMpKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB7IHZhbHVlOiBmYWN0b3J5KCksIGRlcHMgfTtcbiAgfVxuXG4gIHJldHVybiByZWYuY3VycmVudC52YWx1ZTtcbn1cblxuLyoqXG4gKiBMYXp5IGltYWdlIGNvbmZpZ3VyYXRpb25cbiAqL1xuaW50ZXJmYWNlIExhenlJbWFnZUNvbmZpZyB7XG4gIHNyYzogc3RyaW5nO1xuICBwbGFjZWhvbGRlcj86IHN0cmluZztcbiAgdGhyZXNob2xkPzogbnVtYmVyO1xuICByb290TWFyZ2luPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIExhenkgaW1hZ2UgcmV0dXJuIHR5cGVcbiAqL1xuaW50ZXJmYWNlIExhenlJbWFnZVJldHVybiB7XG4gIHJlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxJbWFnZUVsZW1lbnQ+O1xuICBpbWFnZVNyYzogc3RyaW5nO1xuICBpc0xvYWRlZDogYm9vbGVhbjtcbiAgaXNFcnJvcjogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayBmb3IgbGF6eSBsb2FkaW5nIGltYWdlc1xuICogQHBhcmFtIGNvbmZpZyAtIExhenkgaW1hZ2UgY29uZmlndXJhdGlvblxuICogQHJldHVybnMgTGF6eSBpbWFnZSBwcm9wZXJ0aWVzXG4gKiBAZXhhbXBsZVxuICogY29uc3QgeyByZWYsIGltYWdlU3JjLCBpc0xvYWRlZCB9ID0gdXNlTGF6eUltYWdlKHtcbiAqICAgc3JjOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9pbWFnZS5qcGcnLFxuICogICBwbGFjZWhvbGRlcjogJ2h0dHBzOi8vZXhhbXBsZS5jb20vcGxhY2Vob2xkZXIuanBnJ1xuICogfSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXp5SW1hZ2UoY29uZmlnOiBMYXp5SW1hZ2VDb25maWcpOiBMYXp5SW1hZ2VSZXR1cm4ge1xuICBjb25zdCB7IHNyYywgcGxhY2Vob2xkZXIgPSAnJywgdGhyZXNob2xkID0gMCwgcm9vdE1hcmdpbiA9ICc1MHB4JyB9ID0gY29uZmlnO1xuICBjb25zdCBbaW1hZ2VTcmMsIHNldEltYWdlU3JjXSA9IHVzZVN0YXRlKHBsYWNlaG9sZGVyKTtcbiAgY29uc3QgW2lzTG9hZGVkLCBzZXRJc0xvYWRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0Vycm9yLCBzZXRJc0Vycm9yXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgXG4gIGNvbnN0IHsgcmVmLCBpc0ludGVyc2VjdGluZyB9ID0gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXI8SFRNTEltYWdlRWxlbWVudD4oe1xuICAgIHRocmVzaG9sZCxcbiAgICByb290TWFyZ2luLFxuICB9KTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNJbnRlcnNlY3RpbmcgfHwgaXNMb2FkZWQpIHJldHVybjtcblxuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIFxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBzZXRJbWFnZVNyYyhzcmMpO1xuICAgICAgc2V0SXNMb2FkZWQodHJ1ZSk7XG4gICAgICBzZXRJc0Vycm9yKGZhbHNlKTtcbiAgICB9O1xuICAgIFxuICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgc2V0SXNFcnJvcih0cnVlKTtcbiAgICAgIHNldElzTG9hZGVkKHRydWUpO1xuICAgIH07XG4gICAgXG4gICAgaW1nLnNyYyA9IHNyYztcbiAgfSwgW3NyYywgaXNJbnRlcnNlY3RpbmcsIGlzTG9hZGVkXSk7XG5cbiAgcmV0dXJuIHsgcmVmLCBpbWFnZVNyYywgaXNMb2FkZWQsIGlzRXJyb3IgfTtcbn1cblxuLyoqXG4gKiBMZWdhY3kgcHJvZ3Jlc3NpdmUgaW1hZ2UgbG9hZGluZyBob29rXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQcm9ncmVzc2l2ZUltYWdlKHNyYzogc3RyaW5nLCBwbGFjZWhvbGRlclNyYz86IHN0cmluZykge1xuICBjb25zdCBbY3VycmVudFNyYywgc2V0Q3VycmVudFNyY10gPSB1c2VTdGF0ZShwbGFjZWhvbGRlclNyYyB8fCBzcmMpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtpc0Vycm9yLCBzZXRJc0Vycm9yXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIFxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBzZXRDdXJyZW50U3JjKHNyYyk7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH07XG4gICAgXG4gICAgaW1nLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICBzZXRJc0Vycm9yKHRydWUpO1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9O1xuICAgIFxuICAgIGltZy5zcmMgPSBzcmM7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGltZy5vbmxvYWQgPSBudWxsO1xuICAgICAgaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gIH0sIFtzcmNdKTtcblxuICByZXR1cm4ge1xuICAgIHNyYzogY3VycmVudFNyYyxcbiAgICBpc0xvYWRpbmcsXG4gICAgaXNFcnJvcixcbiAgfTtcbn1cblxuLyoqXG4gKiBBbmltYXRpb24gZnJhbWUgYmFzZWQgdXBkYXRlcyBmb3Igc21vb3RoIHBlcmZvcm1hbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBbmltYXRpb25GcmFtZShjYWxsYmFjazogKCkgPT4gdm9pZCwgZGVwczogUmVhY3QuRGVwZW5kZW5jeUxpc3QpIHtcbiAgY29uc3QgcmVxdWVzdFJlZiA9IHVzZVJlZjxudW1iZXI+KCk7XG4gIFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgcmVxdWVzdFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIH07XG4gICAgXG4gICAgcmVxdWVzdFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgZGVwcyk7XG59XG5cbi8qKlxuICogQnVuZGxlIHNpemUgb3B0aW1pemF0aW9uIHV0aWxpdGllc1xuICovXG5leHBvcnQgY29uc3QgbGF6eUltcG9ydCA9IDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4oXG4gIGltcG9ydEZuOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBuYW1lZEV4cG9ydD86IGtleW9mIFRcbikgPT4ge1xuICByZXR1cm4gbGF6eSgoKSA9PlxuICAgIGltcG9ydEZuKCkudGhlbigobW9kdWxlKSA9PiAoe1xuICAgICAgZGVmYXVsdDogbmFtZWRFeHBvcnQgPyBtb2R1bGVbbmFtZWRFeHBvcnRdIDogbW9kdWxlLmRlZmF1bHQgfHwgbW9kdWxlLFxuICAgIH0pKVxuICApO1xufTtcblxuLyoqXG4gKiBDcml0aWNhbCByZXNvdXJjZSBwcmVsb2FkaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVsb2FkUmVzb3VyY2UoaHJlZjogc3RyaW5nLCBhczogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgbGluay5yZWwgPSAncHJlbG9hZCc7XG4gIGxpbmsuaHJlZiA9IGhyZWY7XG4gIGxpbmsuYXMgPSBhcztcbiAgXG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG59XG5cbi8qKlxuICogRE5TIHByZWZldGNoaW5nIGZvciBleHRlcm5hbCByZXNvdXJjZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWZldGNoRE5TKGRvbWFpbjogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgbGluay5yZWwgPSAnZG5zLXByZWZldGNoJztcbiAgbGluay5ocmVmID0gZG9tYWluO1xuICBcbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbn1cblxuLyoqXG4gKiBDb2RlIHNwbGl0dGluZyB1dGlsaXRpZXNcbiAqL1xuZXhwb3J0IGNvbnN0IHdpdGhTdXNwZW5zZSA9IDxQIGV4dGVuZHMgb2JqZWN0PihcbiAgQ29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlPFA+LFxuICBmYWxsYmFjazogUmVhY3QuUmVhY3ROb2RlID0gUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge30sICdMb2FkaW5nLi4uJylcbikgPT4ge1xuICByZXR1cm4gKHByb3BzOiBQKSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIFN1c3BlbnNlLFxuICAgIHsgZmFsbGJhY2sgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgcHJvcHMpXG4gICk7XG59O1xuXG4vKipcbiAqIFJlYWN0IDE5IG9wdGltaXplZCBmb3JtIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPcHRpbWl6ZWRGb3JtPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PihcbiAgaW5pdGlhbFZhbHVlczogVCxcbiAgb25TdWJtaXQ6ICh2YWx1ZXM6IFQpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG4pIHtcbiAgY29uc3QgW3ZhbHVlcywgc2V0VmFsdWVzXSA9IHVzZVN0YXRlPFQ+KGluaXRpYWxWYWx1ZXMpO1xuICBjb25zdCBbaXNTdWJtaXR0aW5nLCBzZXRJc1N1Ym1pdHRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZUNhbGxiYWNrKChuYW1lOiBrZXlvZiBULCB2YWx1ZTogYW55KSA9PiB7XG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIHNldFZhbHVlcyhwcmV2ID0+ICh7IC4uLnByZXYsIFtuYW1lXTogdmFsdWUgfSkpO1xuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKGV2ZW50OiBSZWFjdC5Gb3JtRXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBzZXRJc1N1Ym1pdHRpbmcodHJ1ZSk7XG4gICAgICBhd2FpdCBvblN1Ym1pdCh2YWx1ZXMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1N1Ym1pdHRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW3ZhbHVlcywgb25TdWJtaXRdKTtcblxuICBjb25zdCByZXNldCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgc2V0VmFsdWVzKGluaXRpYWxWYWx1ZXMpO1xuICAgIH0pO1xuICB9LCBbaW5pdGlhbFZhbHVlc10pO1xuXG4gIHJldHVybiB7XG4gICAgdmFsdWVzLFxuICAgIGhhbmRsZUNoYW5nZSxcbiAgICBoYW5kbGVTdWJtaXQsXG4gICAgcmVzZXQsXG4gICAgaXNTdWJtaXR0aW5nLFxuICB9O1xufVxuXG4vKipcbiAqIFBlcmZvcm1hbmNlIGJ1ZGdldCBtb25pdG9yaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQZXJmb3JtYW5jZUJ1ZGdldCgpIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcpIHJldHVybjtcblxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGxpc3QpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgbGlzdC5nZXRFbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKGVudHJ5LmVudHJ5VHlwZSA9PT0gJ21lYXN1cmUnKSB7XG4gICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBlbnRyeS5kdXJhdGlvbjtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZHVyYXRpb24gPiAxMDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW1BlcmZvcm1hbmNlIEJ1ZGdldF0gJHtlbnRyeS5uYW1lfSBleGNlZWRlZCAxMDBtcyBidWRnZXQ6ICR7ZHVyYXRpb24udG9GaXhlZCgyKX1tc2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh7IGVudHJ5VHlwZXM6IFsnbWVhc3VyZSddIH0pO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbXSk7XG59XG5cbi8vIFBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGhlbHBlcnNcbmV4cG9ydCBjb25zdCBtZWFzdXJlUGVyZm9ybWFuY2UgPSB7XG4gIHN0YXJ0OiAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwZXJmb3JtYW5jZS5tYXJrKGAke25hbWV9LXN0YXJ0YCk7XG4gICAgfVxuICB9LFxuICBcbiAgZW5kOiAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwZXJmb3JtYW5jZS5tYXJrKGAke25hbWV9LWVuZGApO1xuICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShuYW1lLCBgJHtuYW1lfS1zdGFydGAsIGAke25hbWV9LWVuZGApO1xuICAgIH1cbiAgfSxcbiAgXG4gIGNsZWFyOiAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGAke25hbWV9LXN0YXJ0YCk7XG4gICAgICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGAke25hbWV9LWVuZGApO1xuICAgICAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9XG4gIH0sXG59O1xuXG4gIl0sIm5hbWVzIjpbImxhenlJbXBvcnQiLCJtZWFzdXJlUGVyZm9ybWFuY2UiLCJwcmVmZXRjaEROUyIsInByZWxvYWRSZXNvdXJjZSIsInVzZUFuaW1hdGlvbkZyYW1lIiwidXNlRGVib3VuY2UiLCJ1c2VEZWJvdW5jZWQiLCJ1c2VEZWVwTWVtbyIsInVzZUludGVyc2VjdGlvbk9ic2VydmVyIiwidXNlTGF6eUltYWdlIiwidXNlTWVtb3J5TW9uaXRvciIsInVzZU9wdGltaXplZEZvcm0iLCJ1c2VQZXJmb3JtYW5jZUJ1ZGdldCIsInVzZVBlcmZvcm1hbmNlTW9uaXRvciIsInVzZVByb2ZpbGVkQ2FsbGJhY2siLCJ1c2VQcm9maWxlZE1lbW8iLCJ1c2VQcm9ncmVzc2l2ZUltYWdlIiwidXNlU3RhYmxlQ2FsbGJhY2siLCJ1c2VUaHJvdHRsZSIsInVzZVRocm90dGxlZCIsInVzZVZpcnR1YWxTY3JvbGwiLCJ1c2VWaXJ0dWFsU2Nyb2xsaW5nIiwid2l0aFN1c3BlbnNlIiwiZmFjdG9yeSIsImRlcHMiLCJkZWJ1Z0xhYmVsIiwidXNlTWVtbyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInN0YXJ0IiwicGVyZm9ybWFuY2UiLCJub3ciLCJyZXN1bHQiLCJlbmQiLCJjb25zb2xlIiwid2FybiIsInRvRml4ZWQiLCJjYWxsYmFjayIsInVzZUNhbGxiYWNrIiwiYXJncyIsInZhbHVlIiwiZGVsYXkiLCJkZWJvdW5jZWRWYWx1ZSIsInNldERlYm91bmNlZFZhbHVlIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJoYW5kbGVyIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsImxhc3RDYWxsIiwidXNlUmVmIiwiRGF0ZSIsImN1cnJlbnQiLCJjb25maWciLCJ0aHJlc2hvbGQiLCJyb290TWFyZ2luIiwicm9vdCIsInJlZiIsImlzSW50ZXJzZWN0aW5nIiwic2V0SXNJbnRlcnNlY3RpbmciLCJlbnRyeSIsInNldEVudHJ5IiwiZWxlbWVudCIsIm9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsIml0ZW1zIiwiaXRlbUhlaWdodCIsImNvbnRhaW5lckhlaWdodCIsIm92ZXJzY2FuIiwic2Nyb2xsVG9wIiwic2V0U2Nyb2xsVG9wIiwidmlzaWJsZVJhbmdlIiwiTWF0aCIsIm1heCIsImZsb29yIiwibWluIiwibGVuZ3RoIiwiY2VpbCIsInRvdGFsSGVpZ2h0Iiwib2Zmc2V0WSIsImhhbmRsZVNjcm9sbCIsImUiLCJ0YXJnZXQiLCJzY3JvbGxDb250YWluZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ2aXNpYmxlSXRlbXMiLCJzbGljZSIsIm1hcCIsIml0ZW0iLCJpbmRleCIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJoZWlnaHQiLCJ3aWR0aCIsImV2ZW50IiwiY3VycmVudFRhcmdldCIsImNvbXBvbmVudE5hbWUiLCJyZW5kZXJTdGFydCIsInJlbmRlckNvdW50IiwicmVuZGVyVGltZSIsImxvZyIsIm1lbW9yeSIsInJvdW5kIiwidXNlZEpTSGVhcFNpemUiLCJjYWxsYmFja1JlZiIsImRlZXBFcXVhbCIsImEiLCJiIiwia2V5c0EiLCJPYmplY3QiLCJrZXlzIiwia2V5c0IiLCJrZXkiLCJpbmNsdWRlcyIsInNyYyIsInBsYWNlaG9sZGVyIiwiaW1hZ2VTcmMiLCJzZXRJbWFnZVNyYyIsImlzTG9hZGVkIiwic2V0SXNMb2FkZWQiLCJpc0Vycm9yIiwic2V0SXNFcnJvciIsImltZyIsIkltYWdlIiwib25sb2FkIiwib25lcnJvciIsInBsYWNlaG9sZGVyU3JjIiwiY3VycmVudFNyYyIsInNldEN1cnJlbnRTcmMiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJyZXF1ZXN0UmVmIiwiYW5pbWF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaW1wb3J0Rm4iLCJuYW1lZEV4cG9ydCIsImxhenkiLCJ0aGVuIiwibW9kdWxlIiwiZGVmYXVsdCIsImhyZWYiLCJhcyIsIndpbmRvdyIsImxpbmsiLCJjcmVhdGVFbGVtZW50IiwicmVsIiwiaGVhZCIsImFwcGVuZENoaWxkIiwiZG9tYWluIiwiQ29tcG9uZW50IiwiZmFsbGJhY2siLCJSZWFjdCIsInByb3BzIiwiU3VzcGVuc2UiLCJpbml0aWFsVmFsdWVzIiwib25TdWJtaXQiLCJ2YWx1ZXMiLCJzZXRWYWx1ZXMiLCJpc1N1Ym1pdHRpbmciLCJzZXRJc1N1Ym1pdHRpbmciLCJoYW5kbGVDaGFuZ2UiLCJuYW1lIiwic3RhcnRUcmFuc2l0aW9uIiwicHJldiIsImhhbmRsZVN1Ym1pdCIsInByZXZlbnREZWZhdWx0IiwicmVzZXQiLCJQZXJmb3JtYW5jZU9ic2VydmVyIiwibGlzdCIsImdldEVudHJpZXMiLCJlbnRyeVR5cGUiLCJkdXJhdGlvbiIsImVudHJ5VHlwZXMiLCJtYXJrIiwibWVhc3VyZSIsImNsZWFyIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQzs7Ozs7Ozs7Ozs7SUFpZ0JZQSxVQUFVO2VBQVZBOztJQTBIQUMsa0JBQWtCO2VBQWxCQTs7SUE5RkdDLFdBQVc7ZUFBWEE7O0lBZEFDLGVBQWU7ZUFBZkE7O0lBcENBQyxpQkFBaUI7ZUFBakJBOztJQTVaSEMsV0FBVztlQUFYQTs7SUFuQkdDLFlBQVk7ZUFBWkE7O0lBNFRBQyxXQUFXO2VBQVhBOztJQS9QQUMsdUJBQXVCO2VBQXZCQTs7SUEwU0FDLFlBQVk7ZUFBWkE7O0lBL0dBQyxnQkFBZ0I7ZUFBaEJBOztJQW9RQUMsZ0JBQWdCO2VBQWhCQTs7SUEwQ0FDLG9CQUFvQjtlQUFwQkE7O0lBMVVBQyxxQkFBcUI7ZUFBckJBOztJQXJQQUMsbUJBQW1CO2VBQW5CQTs7SUF6QkFDLGVBQWU7ZUFBZkE7O0lBNmJBQyxtQkFBbUI7ZUFBbkJBOztJQWxJQUMsaUJBQWlCO2VBQWpCQTs7SUE5TkhDLFdBQVc7ZUFBWEE7O0lBbkJHQyxZQUFZO2VBQVpBOztJQXFHQUMsZ0JBQWdCO2VBQWhCQTs7SUF3Q0FDLG1CQUFtQjtlQUFuQkE7O0lBeVVIQyxZQUFZO2VBQVpBOzs7K0RBeGlCNkc7Ozs7Ozs7Ozs7Ozs7Ozs7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