fa53ba12d62a13479de9623afdb32d5f
/**
 * Optimized Image Component
 * 
 * Enhanced image component with lazy loading, error handling, and performance optimizations.
 * Provides fallback content and automatic optimization for better user experience.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    OptimizedImage: function() {
        return OptimizedImage;
    },
    default: function() {
        return _default;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _image = /*#__PURE__*/ _interop_require_default(require("next/image"));
const _performanceOptimizations = require("../../utils/performanceOptimizations");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * OptimizedImage Component
 * 
 * Features:
 * - Automatic lazy loading with Next.js Image
 * - Error handling with fallback content
 * - Automatic image optimization and compression
 * - Responsive image support
 * - Accessibility compliance
 * - Performance monitoring
 * 
 * @param src - Image source URL
 * @param alt - Alternative text
 * @param width - Image width
 * @param height - Image height
 * @param className - CSS classes
 * @param fallback - Fallback content on error
 * @param priority - Disable lazy loading for above-fold images
 * @param quality - Image quality (1-100)
 * @param placeholder - Placeholder type
 * @param blurDataURL - Blur placeholder data
 * @param sizes - Responsive sizes
 * @param fill - Fill container mode
 * @param objectFit - Object fit behavior
 * @param objectPosition - Object position
 * @param onLoad - Load callback
 * @param onError - Error callback
 */ const OptimizedImageComponent = ({ src, alt, width, height, className = '', fallback, priority = false, quality = 75, placeholder = 'empty', blurDataURL, sizes, fill = false, objectFit = 'cover', objectPosition = 'center', onLoad, onError, enableIntersectionObserver = true, threshold = 0.1 })=>{
    const [hasError, setHasError] = (0, _react.useState)(false);
    const [isLoading, setIsLoading] = (0, _react.useState)(true);
    // Use intersection observer for advanced lazy loading
    const [observerRef, isIntersecting] = (0, _performanceOptimizations.useIntersectionObserver)({
        threshold,
        rootMargin: '50px'
    });
    // Determine if image should load
    const shouldLoad = !enableIntersectionObserver || priority || isIntersecting;
    /**
   * Handle image load success
   */ const handleLoad = (0, _react.useCallback)(()=>{
        setIsLoading(false);
        setHasError(false);
        onLoad?.();
    }, [
        onLoad
    ]);
    /**
   * Handle image load error
   */ const handleError = (0, _react.useCallback)(()=>{
        setIsLoading(false);
        setHasError(true);
        onError?.();
    }, [
        onError
    ]);
    /**
   * Generate blur placeholder for better loading experience
   */ const generatedBlurDataURL = (0, _react.useMemo)(()=>{
        if (blurDataURL) return blurDataURL;
        // Generate a simple colored blur placeholder
        const canvas = typeof window !== 'undefined' ? document.createElement('canvas') : null;
        if (!canvas) return undefined;
        canvas.width = 10;
        canvas.height = 10;
        const ctx = canvas.getContext('2d');
        if (!ctx) return undefined;
        // Create a simple gradient blur effect
        const gradient = ctx.createLinearGradient(0, 0, 10, 10);
        gradient.addColorStop(0, '#f3f4f6');
        gradient.addColorStop(1, '#e5e7eb');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 10, 10);
        return canvas.toDataURL();
    }, [
        blurDataURL
    ]);
    /**
   * Render fallback content when image fails
   */ if (hasError && fallback) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
            className: className,
            children: fallback
        });
    }
    /**
   * Common image props
   */ const imageProps = {
        src,
        alt,
        className: `transition-opacity duration-300 ${isLoading ? 'opacity-0' : 'opacity-100'} ${className}`,
        priority,
        quality,
        placeholder: generatedBlurDataURL ? 'blur' : placeholder,
        blurDataURL: generatedBlurDataURL,
        sizes,
        style: {
            objectFit,
            objectPosition
        },
        onLoad: handleLoad,
        onError: handleError
    };
    // Don't render image if not supposed to load yet
    if (!shouldLoad) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
            ref: observerRef,
            className: `relative bg-gray-200 dark:bg-gray-700 animate-pulse rounded ${className}`,
            style: {
                width: fill ? '100%' : width,
                height: fill ? '100%' : height
            },
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                className: "absolute inset-0 flex items-center justify-center text-gray-400",
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)("svg", {
                    className: "w-6 h-6",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("path", {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        strokeWidth: 2,
                        d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                    })
                })
            })
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
        ref: observerRef,
        className: "relative",
        children: [
            fill ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_image.default, {
                ...imageProps,
                fill: true
            }) : /*#__PURE__*/ (0, _jsxruntime.jsx)(_image.default, {
                ...imageProps,
                width: width,
                height: height
            }),
            isLoading && /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                className: `absolute inset-0 bg-gray-200 dark:bg-gray-700 animate-pulse rounded ${className}`,
                style: {
                    width: fill ? '100%' : width,
                    height: fill ? '100%' : height
                }
            })
        ]
    });
};
const OptimizedImage = /*#__PURE__*/ _react.default.memo(OptimizedImageComponent);
const _default = OptimizedImage;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXZhbi9EZXNrdG9wL0Rldm9wcy1hcHAtZGV2LWN1cnNvci9mcm9udGVuZC9zcmMvY29tcG9uZW50cy91aS9PcHRpbWl6ZWRJbWFnZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPcHRpbWl6ZWQgSW1hZ2UgQ29tcG9uZW50XG4gKiBcbiAqIEVuaGFuY2VkIGltYWdlIGNvbXBvbmVudCB3aXRoIGxhenkgbG9hZGluZywgZXJyb3IgaGFuZGxpbmcsIGFuZCBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zLlxuICogUHJvdmlkZXMgZmFsbGJhY2sgY29udGVudCBhbmQgYXV0b21hdGljIG9wdGltaXphdGlvbiBmb3IgYmV0dGVyIHVzZXIgZXhwZXJpZW5jZS5cbiAqL1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEltYWdlIGZyb20gJ25leHQvaW1hZ2UnO1xuaW1wb3J0IHsgdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgfSBmcm9tICcuLi8uLi91dGlscy9wZXJmb3JtYW5jZU9wdGltaXphdGlvbnMnO1xuXG5pbnRlcmZhY2UgT3B0aW1pemVkSW1hZ2VQcm9wcyB7XG4gIC8qKiBJbWFnZSBzb3VyY2UgVVJMICovXG4gIHNyYzogc3RyaW5nO1xuICAvKiogQWx0ZXJuYXRpdmUgdGV4dCBmb3IgYWNjZXNzaWJpbGl0eSAqL1xuICBhbHQ6IHN0cmluZztcbiAgLyoqIEltYWdlIHdpZHRoICovXG4gIHdpZHRoOiBudW1iZXI7XG4gIC8qKiBJbWFnZSBoZWlnaHQgKi9cbiAgaGVpZ2h0OiBudW1iZXI7XG4gIC8qKiBDU1MgY2xhc3NlcyAqL1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIC8qKiBGYWxsYmFjayBjb250ZW50IHdoZW4gaW1hZ2UgZmFpbHMgdG8gbG9hZCAqL1xuICBmYWxsYmFjaz86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgLyoqIFByaW9yaXR5IGxvYWRpbmcgKGRpc2FibGUgbGF6eSBsb2FkaW5nKSAqL1xuICBwcmlvcml0eT86IGJvb2xlYW47XG4gIC8qKiBJbWFnZSBxdWFsaXR5ICgxLTEwMCkgKi9cbiAgcXVhbGl0eT86IG51bWJlcjtcbiAgLyoqIFBsYWNlaG9sZGVyIHR5cGUgKi9cbiAgcGxhY2Vob2xkZXI/OiAnYmx1cicgfCAnZW1wdHknO1xuICAvKiogQmx1ciBkYXRhIFVSTCBmb3IgcGxhY2Vob2xkZXIgKi9cbiAgYmx1ckRhdGFVUkw/OiBzdHJpbmc7XG4gIC8qKiBTaXplcyBhdHRyaWJ1dGUgZm9yIHJlc3BvbnNpdmUgaW1hZ2VzICovXG4gIHNpemVzPzogc3RyaW5nO1xuICAvKiogRmlsbCBjb250YWluZXIgKG1ha2VzIGltYWdlIHJlc3BvbnNpdmUpICovXG4gIGZpbGw/OiBib29sZWFuO1xuICAvKiogT2JqZWN0IGZpdCBzdHlsZSAqL1xuICBvYmplY3RGaXQ/OiAnY29udGFpbicgfCAnY292ZXInIHwgJ2ZpbGwnIHwgJ25vbmUnIHwgJ3NjYWxlLWRvd24nO1xuICAvKiogT2JqZWN0IHBvc2l0aW9uICovXG4gIG9iamVjdFBvc2l0aW9uPzogc3RyaW5nO1xuICAvKiogQ2FsbGJhY2sgd2hlbiBpbWFnZSBsb2FkcyAqL1xuICBvbkxvYWQ/OiAoKSA9PiB2b2lkO1xuICAvKiogQ2FsbGJhY2sgd2hlbiBpbWFnZSBmYWlscyB0byBsb2FkICovXG4gIG9uRXJyb3I/OiAoKSA9PiB2b2lkO1xuICAvKiogRW5hYmxlIGludGVyc2VjdGlvbiBvYnNlcnZlciBsYXp5IGxvYWRpbmcgKi9cbiAgZW5hYmxlSW50ZXJzZWN0aW9uT2JzZXJ2ZXI/OiBib29sZWFuO1xuICAvKiogSW50ZXJzZWN0aW9uIG9ic2VydmVyIHRocmVzaG9sZCAqL1xuICB0aHJlc2hvbGQ/OiBudW1iZXI7XG59XG5cbi8qKlxuICogT3B0aW1pemVkSW1hZ2UgQ29tcG9uZW50XG4gKiBcbiAqIEZlYXR1cmVzOlxuICogLSBBdXRvbWF0aWMgbGF6eSBsb2FkaW5nIHdpdGggTmV4dC5qcyBJbWFnZVxuICogLSBFcnJvciBoYW5kbGluZyB3aXRoIGZhbGxiYWNrIGNvbnRlbnRcbiAqIC0gQXV0b21hdGljIGltYWdlIG9wdGltaXphdGlvbiBhbmQgY29tcHJlc3Npb25cbiAqIC0gUmVzcG9uc2l2ZSBpbWFnZSBzdXBwb3J0XG4gKiAtIEFjY2Vzc2liaWxpdHkgY29tcGxpYW5jZVxuICogLSBQZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gKiBcbiAqIEBwYXJhbSBzcmMgLSBJbWFnZSBzb3VyY2UgVVJMXG4gKiBAcGFyYW0gYWx0IC0gQWx0ZXJuYXRpdmUgdGV4dFxuICogQHBhcmFtIHdpZHRoIC0gSW1hZ2Ugd2lkdGhcbiAqIEBwYXJhbSBoZWlnaHQgLSBJbWFnZSBoZWlnaHRcbiAqIEBwYXJhbSBjbGFzc05hbWUgLSBDU1MgY2xhc3Nlc1xuICogQHBhcmFtIGZhbGxiYWNrIC0gRmFsbGJhY2sgY29udGVudCBvbiBlcnJvclxuICogQHBhcmFtIHByaW9yaXR5IC0gRGlzYWJsZSBsYXp5IGxvYWRpbmcgZm9yIGFib3ZlLWZvbGQgaW1hZ2VzXG4gKiBAcGFyYW0gcXVhbGl0eSAtIEltYWdlIHF1YWxpdHkgKDEtMTAwKVxuICogQHBhcmFtIHBsYWNlaG9sZGVyIC0gUGxhY2Vob2xkZXIgdHlwZVxuICogQHBhcmFtIGJsdXJEYXRhVVJMIC0gQmx1ciBwbGFjZWhvbGRlciBkYXRhXG4gKiBAcGFyYW0gc2l6ZXMgLSBSZXNwb25zaXZlIHNpemVzXG4gKiBAcGFyYW0gZmlsbCAtIEZpbGwgY29udGFpbmVyIG1vZGVcbiAqIEBwYXJhbSBvYmplY3RGaXQgLSBPYmplY3QgZml0IGJlaGF2aW9yXG4gKiBAcGFyYW0gb2JqZWN0UG9zaXRpb24gLSBPYmplY3QgcG9zaXRpb25cbiAqIEBwYXJhbSBvbkxvYWQgLSBMb2FkIGNhbGxiYWNrXG4gKiBAcGFyYW0gb25FcnJvciAtIEVycm9yIGNhbGxiYWNrXG4gKi9cbmNvbnN0IE9wdGltaXplZEltYWdlQ29tcG9uZW50OiBSZWFjdC5GQzxPcHRpbWl6ZWRJbWFnZVByb3BzPiA9ICh7XG4gIHNyYyxcbiAgYWx0LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBjbGFzc05hbWUgPSAnJyxcbiAgZmFsbGJhY2ssXG4gIHByaW9yaXR5ID0gZmFsc2UsXG4gIHF1YWxpdHkgPSA3NSxcbiAgcGxhY2Vob2xkZXIgPSAnZW1wdHknLFxuICBibHVyRGF0YVVSTCxcbiAgc2l6ZXMsXG4gIGZpbGwgPSBmYWxzZSxcbiAgb2JqZWN0Rml0ID0gJ2NvdmVyJyxcbiAgb2JqZWN0UG9zaXRpb24gPSAnY2VudGVyJyxcbiAgb25Mb2FkLFxuICBvbkVycm9yLFxuICBlbmFibGVJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHRydWUsXG4gIHRocmVzaG9sZCA9IDAuMSxcbn0pID0+IHtcbiAgY29uc3QgW2hhc0Vycm9yLCBzZXRIYXNFcnJvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgXG4gIC8vIFVzZSBpbnRlcnNlY3Rpb24gb2JzZXJ2ZXIgZm9yIGFkdmFuY2VkIGxhenkgbG9hZGluZ1xuICBjb25zdCBbb2JzZXJ2ZXJSZWYsIGlzSW50ZXJzZWN0aW5nXSA9IHVzZUludGVyc2VjdGlvbk9ic2VydmVyKHtcbiAgICB0aHJlc2hvbGQsXG4gICAgcm9vdE1hcmdpbjogJzUwcHgnLCAvLyBTdGFydCBsb2FkaW5nIDUwcHggYmVmb3JlIGltYWdlIGVudGVycyB2aWV3cG9ydFxuICB9KTtcbiAgXG4gIC8vIERldGVybWluZSBpZiBpbWFnZSBzaG91bGQgbG9hZFxuICBjb25zdCBzaG91bGRMb2FkID0gIWVuYWJsZUludGVyc2VjdGlvbk9ic2VydmVyIHx8IHByaW9yaXR5IHx8IGlzSW50ZXJzZWN0aW5nO1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgaW1hZ2UgbG9hZCBzdWNjZXNzXG4gICAqL1xuICBjb25zdCBoYW5kbGVMb2FkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgc2V0SGFzRXJyb3IoZmFsc2UpO1xuICAgIG9uTG9hZD8uKCk7XG4gIH0sIFtvbkxvYWRdKTtcblxuICAvKipcbiAgICogSGFuZGxlIGltYWdlIGxvYWQgZXJyb3JcbiAgICovXG4gIGNvbnN0IGhhbmRsZUVycm9yID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgc2V0SGFzRXJyb3IodHJ1ZSk7XG4gICAgb25FcnJvcj8uKCk7XG4gIH0sIFtvbkVycm9yXSk7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGJsdXIgcGxhY2Vob2xkZXIgZm9yIGJldHRlciBsb2FkaW5nIGV4cGVyaWVuY2VcbiAgICovXG4gIGNvbnN0IGdlbmVyYXRlZEJsdXJEYXRhVVJMID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGJsdXJEYXRhVVJMKSByZXR1cm4gYmx1ckRhdGFVUkw7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgYSBzaW1wbGUgY29sb3JlZCBibHVyIHBsYWNlaG9sZGVyXG4gICAgY29uc3QgY2FudmFzID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSA6IG51bGw7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgY2FudmFzLndpZHRoID0gMTA7XG4gICAgY2FudmFzLmhlaWdodCA9IDEwO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmICghY3R4KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHNpbXBsZSBncmFkaWVudCBibHVyIGVmZmVjdFxuICAgIGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDEwLCAxMCk7XG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjZjNmNGY2Jyk7XG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjZTVlN2ViJyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCAxMCwgMTApO1xuICAgIFxuICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG4gIH0sIFtibHVyRGF0YVVSTF0pO1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgZmFsbGJhY2sgY29udGVudCB3aGVuIGltYWdlIGZhaWxzXG4gICAqL1xuICBpZiAoaGFzRXJyb3IgJiYgZmFsbGJhY2spIHtcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+e2ZhbGxiYWNrfTwvZGl2PjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21tb24gaW1hZ2UgcHJvcHNcbiAgICovXG4gIGNvbnN0IGltYWdlUHJvcHMgPSB7XG4gICAgc3JjLFxuICAgIGFsdCxcbiAgICBjbGFzc05hbWU6IGB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tMzAwICR7aXNMb2FkaW5nID8gJ29wYWNpdHktMCcgOiAnb3BhY2l0eS0xMDAnfSAke2NsYXNzTmFtZX1gLFxuICAgIHByaW9yaXR5LFxuICAgIHF1YWxpdHksXG4gICAgcGxhY2Vob2xkZXI6IGdlbmVyYXRlZEJsdXJEYXRhVVJMID8gJ2JsdXInIGFzIGNvbnN0IDogcGxhY2Vob2xkZXIsXG4gICAgYmx1ckRhdGFVUkw6IGdlbmVyYXRlZEJsdXJEYXRhVVJMLFxuICAgIHNpemVzLFxuICAgIHN0eWxlOiB7XG4gICAgICBvYmplY3RGaXQsXG4gICAgICBvYmplY3RQb3NpdGlvbixcbiAgICB9LFxuICAgIG9uTG9hZDogaGFuZGxlTG9hZCxcbiAgICBvbkVycm9yOiBoYW5kbGVFcnJvcixcbiAgfTtcblxuICAvLyBEb24ndCByZW5kZXIgaW1hZ2UgaWYgbm90IHN1cHBvc2VkIHRvIGxvYWQgeWV0XG4gIGlmICghc2hvdWxkTG9hZCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IFxuICAgICAgICByZWY9e29ic2VydmVyUmVmfVxuICAgICAgICBjbGFzc05hbWU9e2ByZWxhdGl2ZSBiZy1ncmF5LTIwMCBkYXJrOmJnLWdyYXktNzAwIGFuaW1hdGUtcHVsc2Ugcm91bmRlZCAke2NsYXNzTmFtZX1gfVxuICAgICAgICBzdHlsZT17eyB3aWR0aDogZmlsbCA/ICcxMDAlJyA6IHdpZHRoLCBoZWlnaHQ6IGZpbGwgPyAnMTAwJScgOiBoZWlnaHQgfX1cbiAgICAgID5cbiAgICAgICAgey8qIFBsYWNlaG9sZGVyIGNvbnRlbnQgKi99XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB0ZXh0LWdyYXktNDAwXCI+XG4gICAgICAgICAgPHN2ZyBjbGFzc05hbWU9XCJ3LTYgaC02XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgICA8cGF0aCBzdHJva2VMaW5lY2FwPVwicm91bmRcIiBzdHJva2VMaW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlV2lkdGg9ezJ9IGQ9XCJNNCAxNmw0LjU4Ni00LjU4NmEyIDIgMCAwMTIuODI4IDBMMTYgMTZtLTItMmwxLjU4Ni0xLjU4NmEyIDIgMCAwMTIuODI4IDBMMjAgMTRtLTYtNmguMDFNNiAyMGgxMmEyIDIgMCAwMDItMlY2YTIgMiAwIDAwLTItMkg2YTIgMiAwIDAwLTIgMnYxMmEyIDIgMCAwMDIgMnpcIiAvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgcmVmPXtvYnNlcnZlclJlZn0gY2xhc3NOYW1lPVwicmVsYXRpdmVcIj5cbiAgICAgIHtmaWxsID8gKFxuICAgICAgICA8SW1hZ2VcbiAgICAgICAgICB7Li4uaW1hZ2VQcm9wc31cbiAgICAgICAgICBmaWxsXG4gICAgICAgIC8+XG4gICAgICApIDogKFxuICAgICAgICA8SW1hZ2VcbiAgICAgICAgICB7Li4uaW1hZ2VQcm9wc31cbiAgICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgICAgXG4gICAgICB7LyogTG9hZGluZyBpbmRpY2F0b3IgKi99XG4gICAgICB7aXNMb2FkaW5nICYmIChcbiAgICAgICAgPGRpdiBcbiAgICAgICAgICBjbGFzc05hbWU9e2BhYnNvbHV0ZSBpbnNldC0wIGJnLWdyYXktMjAwIGRhcms6YmctZ3JheS03MDAgYW5pbWF0ZS1wdWxzZSByb3VuZGVkICR7Y2xhc3NOYW1lfWB9XG4gICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IGZpbGwgPyAnMTAwJScgOiB3aWR0aCwgaGVpZ2h0OiBmaWxsID8gJzEwMCUnIDogaGVpZ2h0IH19XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLyoqXG4gKiBNZW1vaXplZCBPcHRpbWl6ZWRJbWFnZSBjb21wb25lbnQgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBPcHRpbWl6ZWRJbWFnZSA9IFJlYWN0Lm1lbW8oT3B0aW1pemVkSW1hZ2VDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBPcHRpbWl6ZWRJbWFnZTsgIl0sIm5hbWVzIjpbIk9wdGltaXplZEltYWdlIiwiT3B0aW1pemVkSW1hZ2VDb21wb25lbnQiLCJzcmMiLCJhbHQiLCJ3aWR0aCIsImhlaWdodCIsImNsYXNzTmFtZSIsImZhbGxiYWNrIiwicHJpb3JpdHkiLCJxdWFsaXR5IiwicGxhY2Vob2xkZXIiLCJibHVyRGF0YVVSTCIsInNpemVzIiwiZmlsbCIsIm9iamVjdEZpdCIsIm9iamVjdFBvc2l0aW9uIiwib25Mb2FkIiwib25FcnJvciIsImVuYWJsZUludGVyc2VjdGlvbk9ic2VydmVyIiwidGhyZXNob2xkIiwiaGFzRXJyb3IiLCJzZXRIYXNFcnJvciIsInVzZVN0YXRlIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwib2JzZXJ2ZXJSZWYiLCJpc0ludGVyc2VjdGluZyIsInVzZUludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdE1hcmdpbiIsInNob3VsZExvYWQiLCJoYW5kbGVMb2FkIiwidXNlQ2FsbGJhY2siLCJoYW5kbGVFcnJvciIsImdlbmVyYXRlZEJsdXJEYXRhVVJMIiwidXNlTWVtbyIsImNhbnZhcyIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInVuZGVmaW5lZCIsImN0eCIsImdldENvbnRleHQiLCJncmFkaWVudCIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiYWRkQ29sb3JTdG9wIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0b0RhdGFVUkwiLCJkaXYiLCJpbWFnZVByb3BzIiwic3R5bGUiLCJyZWYiLCJzdmciLCJzdHJva2UiLCJ2aWV3Qm94IiwicGF0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN0cm9rZVdpZHRoIiwiZCIsIkltYWdlIiwiUmVhY3QiLCJtZW1vIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7Ozs7Ozs7Ozs7SUE4TllBLGNBQWM7ZUFBZEE7O0lBRWIsT0FBOEI7ZUFBOUI7Ozs7K0RBOU5zRDs4REFDcEM7MENBQ3NCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlDeEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJCQyxHQUNELE1BQU1DLDBCQUF5RCxDQUFDLEVBQzlEQyxHQUFHLEVBQ0hDLEdBQUcsRUFDSEMsS0FBSyxFQUNMQyxNQUFNLEVBQ05DLFlBQVksRUFBRSxFQUNkQyxRQUFRLEVBQ1JDLFdBQVcsS0FBSyxFQUNoQkMsVUFBVSxFQUFFLEVBQ1pDLGNBQWMsT0FBTyxFQUNyQkMsV0FBVyxFQUNYQyxLQUFLLEVBQ0xDLE9BQU8sS0FBSyxFQUNaQyxZQUFZLE9BQU8sRUFDbkJDLGlCQUFpQixRQUFRLEVBQ3pC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