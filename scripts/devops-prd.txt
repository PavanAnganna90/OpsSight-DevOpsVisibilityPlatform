<context>
# Overview

OpsSight is a DevOps Visibility Platform that helps engineering managers and SREs monitor the health, automation, and progress of their CI/CD pipelines, infrastructure as code (IaC) executions, Kubernetes clusters, and policy enforcement in real time. It solves the common problem of fragmented DevOps tooling by providing a unified dashboard to track and visually assess system state, automation coverage, and deployment velocity — all in one place.

It’s designed for:

* **Engineering Managers**: who need visibility into CI/CD reliability, change frequency, and infra cost.
* **DevOps Engineers**: who want centralized insight into automation scripts and live infra health.
* **Interview Candidates**: who want to showcase real-world DevOps understanding via a polished app.

# Core Features

* **CI/CD Pipeline Health Dashboard**
  Shows success/failure rates, durations, frequency of deploys. Pulls data from GitHub Actions or GitLab CI.
  *Why it matters*: Helps managers assess deployment velocity and reliability.

* **Kubernetes Cluster Status Panel**
  Live view of nodes, pods, autoscaling events, resource consumption using Prometheus.
  *Why it matters*: Enables real-time cluster debugging and monitoring.

* **Terraform Execution Logs Viewer**
  Reads plan and apply logs, shows changes per module and risk level.
  *Why it matters*: Helps managers understand infra changes and track failures.

* **Ansible Automation Coverage View**
  Visualizes which machines/scripts were automated via playbook logs.
  *Why it matters*: Shows progress of manual-to-automated infra transitions.

* **Slack/Webhook Alert Summary**
  Pulls in incident or alert data from Slack channels or Webhooks to tag CI failures or infra issues.
  *Why it matters*: Provides contextual visibility into the “why” behind failures.

* **Git Activity Heatmap**
  Pulls metadata from PRs, branches, commits. Displays recent merge activities and velocity.
  *Why it matters*: Gives insights into developer activity and release cadence.

* **Infra Cost Metrics Panel**
  Uses AWS Cost Explorer API to show service-wise cost breakdown and trends.
  *Why it matters*: Helps managers optimize and forecast cloud spend.

# User Experience

* **User Personas**

  * DevOps Engineer: Wants a real-time view of automation health and infra state.
  * Engineering Manager: Needs a simple visual of delivery metrics and system reliability.

* **Key User Flows**

  * Manager logs in → selects team → sees high-level view of deploy success, cluster health, automation coverage.
  * DevOps engineer clicks into failed terraform or Ansible logs → remediates the issue → re-runs the pipeline.

* **UI/UX Considerations**

  * Responsive, clean dashboard using cards and status indicators.
  * Drill-downs from high-level metrics into log-level details.
  * Night-mode friendly; designed for long-monitoring sessions.
  * Uses GitHub OAuth or simple token auth for login.

# Technical Architecture

* **System Components**

  * Frontend: React + Tailwind UI
  * Backend: FastAPI (Python)
  * CI/CD: GitHub Actions for backend and K8s deploy
  * Infrastructure: Deployed to AWS (EKS or EC2-based K8s, S3 for static assets, CloudWatch for logs)
  * Logging & Monitoring: Prometheus, Grafana, ELK (optional)

* **Data Models**

  * Pipelines: status, timestamp, duration, branch, error
  * Clusters: nodes, pods, usage, health
  * Automation: Ansible play logs (host, play, success/failure)
  * Infra Changes: Terraform logs (resource type, change type, status)
  * Alerts: channel, source, message, status

* **APIs & Integrations**

  * GitHub/GitLab API
  * Prometheus API
  * AWS Cost Explorer API
  * Slack Webhook listener
  * Optional: CloudWatch or ELK for logs

* **Infrastructure Requirements**

  * Kubernetes cluster (local via `kind` or AWS EKS)
  * Persistent storage for logs (S3 or EFS)
  * Secure secrets store (SSM, Vault, or env vars)
  * OAuth or token-based auth

# Development Roadmap

### Phase 1: MVP

* GitHub Actions Dashboard (last 10 runs)
* Terraform Logs parser + UI component
* K8s Pod status view (from Prometheus)
* Ansible playbook status extractor
* Simple dashboard UI
* Slack alert collector + display
* GitHub OAuth login

### Phase 2: Core Enhancements

* AWS Cost Explorer Integration
* Cluster autoscaling history visual
* CI/CD failure categorization (infra vs code)
* Export/print PDF summary reports
* RBAC: Team vs Manager access
* Add notifications (email/slack digest)

### Phase 3: Advanced Analytics

* Correlation engine: “Which infra change caused recent deploy failures?”
* ML-based anomaly detection on pipeline runtimes
* Cloud cost anomaly alerts
* Multi-team dashboards with usage heatmaps

# Logical Dependency Chain

1. **Foundation**

   * OAuth login
   * Simple DB or JSON backend for logs
   * GitHub Actions + Terraform log parser

2. **Minimum Visible Demo**

   * Static dashboard with deploy statuses
   * Working log views and cluster status
   * Static JSON mock + frontend integration

3. **Build on Top**

   * Dynamic log polling
   * Prometheus integration
   * Terraform log diff viewer
   * Slack/Alert panel
   * Add AWS costs + Git heatmap
   * Role-based views

# Risks and Mitigations

* **Technical Challenge**: Parsing inconsistent CI/CD and IaC logs
  *Mitigation*: Standardize JSON log formats and fallback to regex parsers.

* **MVP Scope Creep**: Too many integrations too fast
  *Mitigation*: Phase out integrations and only stub complex views in MVP.

* **Infra Cost/API Limits**: Using AWS/Slack APIs for real metrics
  *Mitigation*: Mock with sandbox data; use dev credentials sparingly

* **Time Constraint**: 1-month deadline
  *Mitigation*: Prioritize visible features that make the dashboard feel alive (pipeline tracker, pod status)

# Appendix

* **Research Findings**

  * 70% of teams use >3 tools for monitoring deployments
  * No open-source tools combine Git, K8s, IaC, and Alerts natively in one UI

* **Technical Specs**

  * React 18, Tailwind 3, FastAPI, Python 3.11
  * GitHub REST v3, Prometheus HTTP API, AWS Cost Explorer v2
  * Deployed via GitHub Actions to EKS (or `kind` cluster for demo)

</PRD>